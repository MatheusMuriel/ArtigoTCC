\chapter{Introdução}
%% Introdução ao que vai ser o trabalho %%
Em um ambiente de produção industrial moderna a optimização é um ponto de grande importância, devido a constante mudança e alta concorrência. Em ramos como a manufatura isso se mostra especialmente importante, podendo ser o fator decisório para o sucesso de uma empresa \cite{Wari2016}.\newline

Um dos exemplos de otimização dentro de sistemas de manufatura é dentro de um cenário onde existem diversas máquinas independentes e uma fila de tarefas não homogêneas, e o objetivo é achar uma programação de onde cada tarefa será executada e em qual ordem, de maneira a economizar o máximo de tempo e energia.\newline

Em um ambiente de alta concorrência é importante que essa ordem seja encontrada o quanto antes, pois essa demora para encontrar a solução significa perda de tempo de produção. Porém a busca de um bom escalonamento, ou seja, a configuração e ordem de execução, não é uma tarefa fácil. Pois o número de possibilidades de arranjos cresce exponencialmente, e computar todas as soluções possíveis torna-se inviável após alguns níveis. \newline

Por causa dessa característica exponencial de acordo com o número de máquinas e o número de problemas, esse problema de escalonamento é classificado como um problema de otimização de análise combinatória e pertence a classe de problemas \textit{NP-Hard}. \newline

Os problemas da classe \textit{NP-Hard} são aqueles em que a resposta não pode ser encontrada computacionalmente em um tempo polinomial, ou seja, em um tempo razoável, porém uma solução pode ser verificada em tempo polinomial \cite{Eswaramurthy2008}.\newline

Existem diversos problemas clássicos de produção e manufatura que são enquadrados em problemas de otimização e escalonamento, o que torna esse assunto uma área de muito interesse para pesquisadores do mundo inteiro.\newline

Dentre os problemas clássicos de escalonamento e planejamento de produção estão: 
\textit{Single Machine Scheduling Problem}, 
\textit{Parallel Machine Scheduling Problem}, 
\textit{Flow Shop Scheduling Problem}, 
\textit{Job Shop Scheduling Problem} e 
\textit{Open Shop Scheduling Problem} 
\cite{Allahverdi2008}.\newline

Como esses problemas não são possíveis de serem resolvidos em tempo polinomial, não é possível encontrar uma solução perfeita para eles. Mas é possível encontrarmos uma solução boa o suficiente, de acordo com os critérios de avaliação do problema, essa solução é chamada de solução ótima.\newline

Job Shop Scheduling Problem (JSSP) é um do problema pertencente a classe de problemas \textit{NP-Hard}, ele chama muito a atenção de pesquisadores por ser um problema com diversas aplicações no mundo real, seja em ambientes de manufatura ou em planejamento de produção ou até mesmo em logística \cite{Cheng1996}.\newline

Nesse problema, temos um conjunto $m$ de máquinas e um conjunto $n$ de tarefas chamadas de \textit{jobs}, sendo cada \textit{job} uma sequência de operações, cada uma com seu determinado tempo de execução. \newline 

O objetivo é encontrar um escalonamento que combine todas as máquinas de forma que minimize a quantidade de tempo ocioso de cada máquina, assim atingindo o objetivos de forma mais econômica e eficiente \cite{Cheng1996}. \newline

O problema de JSP é comprovadamente pertencente à classe \textit{NP-Hard} quando em um ambiente com duas ou mais máquinas, como demonstrado por \cite{Lenstra1979}. \newline

Porém, assim como visto por \cite{Bagchi1999} existem algumas restrições no cenário de JSP, dentre elas:
\begin{itemize}
    \item Duas operações do mesmo \textit{job} não podem ser executadas ao mesmo tempo;
    \item Nenhuma máquina pode executar simultaneamente mais de uma operação;
    \item As restrições e configurações de processamento são conhecidas previamente e não são alteradas;
    \item Todo \textit{job} deve ser processado até o fim, mas é permitido que haja pausas e esperas entre suas operações;
    \item As máquinas são homogêneas;
    \item Nenhum \textit{job} pode ser processado duas vezes na mesma máquina;
    \item As operações são atômicas, não sendo possível interromper ou pausar a execução da mesma;
\end{itemize}

O problema de Job Shop Flexível ou \textit{Flexible Job Shop Problem} (FJSP) é uma extensão do JSP onde é possível que uma operação seja executada em mais de uma máquina. Sendo assim deve se além de determinar a ordem e o local de execução de cada \textit{job}, também é preciso que seja determinada ordem e local de execução das operações. Assim sendo considerado uma extensão mais complexa do JSP \cite{Jansen2000}. \newline

Além disso, o problema de FJSP pode ser dividido em dois tipos, o parcial (P-FJSP), onde uma operação só pode ser executada por um subconjunto de máquinas, ou o total (T-FJSP), onde qualquer operação pode ser executada por qualquer máquina. O FJSP tem as mesmas restrições do JSP exceto a que diz que nenhum \textit{job} pode ser processado duas vezes na mesma máquina. \newline

Ao longo do tempo já foram propostas diversas abordagens para resolver o problema de FJSP, dentre elas o \textit{Branch and Bound} \cite{Nababan2008}, a 
\textit{Integer Programming} \cite{Pan2007}, a 
\textit{Dynamic Programming} \cite{Gromicho2012}, 
\textit{Evolutionary Algorithm} \cite{Pezzella2008}, e até mesmo técnicas híbridas \cite{Zhang2009}, onde duas ou mais abordagens são associadas para compor um algoritmo híbrido. \newline

Um desses algoritmos propostos é o algoritmo de Otimização por Enxame de Partículas ou \textit{Particle Swarm Optimization} (PSO) proposto por \cite{Kennedy1995} e trabalha com um grupo de indivíduos cada um tendo: direção, velocidade, a informação da sua melhor posição e a informação da melhor posição entre todos os indivíduos do grupo, e com essas informações cada indivíduo consegue tirar sua média e a cada rodada do algoritmo ir chegando mais perto do objetivo. \newline

Outra abordagem que tem tido bons resultados em diversos problemas práticos \cite{Qing2012} são os Algoritmos Genéticos ou \textit{Genetic Algorithms} (GA), que foi proposto por \textit{John Henry Holland} e é inspirado na teoria da evolução de Charles Darwin, simulando a transmissão de genes dos indivíduos mais aptos por meio da simulação de operações de cruzamento e de mutações, de forma a selecionar os indivíduos mais aptos. \newline

Neste trabalho iremos demonstrar e comparar a eficiência de uma abordagem híbrida do Algoritmo PSO com componentes evolutivos de GA, tornando assim esse algoritmo mais dinâmico, além de demonstrar sua eficiência em diferentes cenários reais de aplicação na indústria.\newline

%% Fim Introdução %%

%% TODO - Expandir Estado da Arte %%























\section{Problemas de Agendamento}
Problemas de agendamento estão muito presentes nos dias atuais, e existem diretamente em diversos cenários, tais como planejamento de produção, sistemas de manufatura, sistemas de produção, processamento de informação, gerenciamento de rotas de logísticas e etc... e indiretamente nos computadores através do escalonamento de processos do sistema operacional.\newline

Com tantos possíveis cenários de aplicação é natural que existam inúmeras sub-divisões deste problema. Porém a maioria deles tem características em comum. No geral eles se baseiam em um conjunto de recursos e um conjunto de demandas, e tem como objetivo ordenar as execuções das demandas e as distribuir entre os recursos, isso afim de alcançar da melhor possível um ou mais objetivos, que podem ser por exemplo o tempo total para o algoritmo executar o agendamento (também chamado de \textit{makespan}), o tempo total de execução de todas as tarefas no agendamento encontrado (também chamado de \textit{fitness}) ou a soma total do tempo de ociosidade das maquinas.\newline

Por essa característica de buscar um melhor resultado em um objetivo os problemas de agendamento são caracterizados como problemas de optimização, que são os problemas que a solução são aquelas que trazem um melhor resultado para o objetivo. É importante ressaltar que nesses problemas de optimização a solução não necessariamente precisa a melhor possível, mas sim uma solução boa o suficiente (também chamado de solução ótima).\newline

Os problemas de agendamento multi-objetivo consideram ao mesmo tempo mais de um critério de avaliação, podendo ter ou não o mesmo peso ou nível de importância, e espera se que sejam atingidos todos os objetivos. Por causa dessa diversidade de objetivos que podem muitas vezes serem conflitantes entre si, como por exemplo ser mais rápido e ao mesmo tempo gastar a menor quantidade possível de energia.\newline

Já os problemas de agendamento mono-objetivo lidam somente com um critério de avaliação, o que diminui significativamente a dificuldade para encontrar um solução, porém em contra partida define uma importância maior para o objetivo em questão, sendo necessário um maior nível de refinamento da solução.



\subsection{Definição}
Como foi definido por \cite{Bagchi1999} um problema de escalonamento de tarefas computacionais (\textit{jobs}) é um problema de otimização aonde os recursos limitados são alocados no tempo de execução dos recursos, com as diferentes tarefas podendo ser executadas em paralelo entre as diversas maquinas, porém cada atividade única sendo executada sequenciamento em uma só maquina.\newline

Assim como a grande maioria dos problemas de origem combinatória, ou seja que um fator depende o fator anterior, formando assim uma combinação de fatores, o problema de escalonamento é um problema da classe NP-Hard da qual não é possível se encontrar a melhor solução possível em um tempo polinomial, ou seja, computacionalmente aceitável, devido a sua quantidade de operações necessárias crescer exponencialmente, com base no tamanho do problema, tornando se assim um problema inviável de se resolver através de cálculos brutos.\newline

Por causa disso nesses casos de problemas NP-Hard normalmente se usam algoritmos de aproximação, que tenham um tempo de execução razoável e que consigam encontrar uma solução boa o suficiente com base nos critérios de avaliação, a chamada "Solução Ótima", como visto por \cite{Laler1993}.\newline

Porém esse conceito de solução ótima varia de acordo com o problema, em alguns casos é mais importante que essa solução seja encontrada em um tempo curto, do que ela seja alguns milissegundos mais rápida do que as outras soluções já encontradas, isso se aplica em ambientes que o agendamento deve ser feito em tempo real.\newline
Já para um problema em que essa solução precisa ser encontrada apenas uma vez e ser replicada varias vezes, como uma estrutura de linha de montagem definitiva, vale a pena esperar algumas horas a mais se essa solução economizar tempo de produção ao longo do seu uso. Então esse critério de avaliação de solução ótima deve ser muito bem analisado de caso a caso. \newline

Nesses ambientes de soluções aproximadas, alguns algoritmos que se destacam são os algoritmos bio inspirados, algoritmos populacionais e algoritmos evolutivos. Que são capazes de simular uma inteligencia biológica ou comportamentos já observados na natureza e selecionados pela evolução para encontrar uma solução ótima, de maneira similar a que um ser vivo faria.


\subsection{Problema}
Diversos autores já classificaram diversas variações de problemas de escalonamento dentre eles \cite{graham1979}, \cite{vaca1995}, \cite{Lenstra1979}, e \cite{maccarthy1993}. O que diferencia os problemas são o fluxo dos \textit{jobs} a serem processados e a capacidade dos recursos. Dentre esses problemas estão:
\begin{itemize}
    \item \textbf{\textit{Open Shop:}} Os \textit{job} tem uma ordem de execução, porém as operações de cada \textit{job} tem uma ordem específica de execução.
    
    \item \textbf{\textit{Flow Shop:}} Os \textit{jobs} devem ser executados em um fluxo unidirecional e em uma maquina somente. E não exite uma divisão do \textit{jobs} em operações.
    
    \item \textbf{\textit{Flexible Flow Shop:}} Semelhante ao \textit{Flow Shop}, porém os \textit{jobs} podem ser divididos em operações.
    
    \item \textbf{\textit{Job Shop:}} Diferentemente do \textit{Flow Shop} o \textit{Job Shop} pode ter execuções paralelas, assim como ser dividido em operações.
    
    \item \textbf{\textit{Flexible Job Shop:}} Uma extensão do \textit{Job Shop} em que as operações de cada \textit{Job} podem ser executados em maquinas diferentes
\end{itemize}
Esse trabalho é focado no \textit{Flexible Job Shop}, em um contexto mono-objetivo




\subsection{Problema de Job Shop - JSP} 
%% Oque é o problema de JSP Simples %%
Como citado anteriormente o \textit{Job Shop Problem} (JSP) é um problema de escalonamento de tarefas e pertence a classe de problemas NP-Hard. Como visto por \cite{Cheng1996} o problema de \textit{Job Shop} chama muita atenção por ser um problema com diversas aplicações no mundo real, e em diversos cenários diferentes, como industria, computação e manufatura.\newline

De acordo com \cite{Cheng1996} o problema de \textit{Job Shop} consiste em $m$ máquinas distintas e $n$ \textit{jobs} diferentes, sendo cada \textit{job} formado por diversas operações $O$ em uma ordem especifica. Cada operação $Oij$ tem seu respectivo tempo de execução.\newline

Como visto por \cite{Bagchi1999} existem algumas restrições no problema de \textit{Job Shop} dentre elas:
\begin{itemize}
    \item Mais de uma operação de um mesmo \textit{job} não pode ser executada ao mesmo tempo.
    \item Não existe mais de uma maquina de um mesmo tipo.
    \item As máquinas podem ficar ociosas durante o período de escalonamento.
    \item As execuções de \textit{jobs} são atômicas, ou seja cada \textit{job} deve ser processado até o fim.
    \item Uma máquina não pode executar mais de uma operação simultaneamente.
    \item Um \textit{job} não é processado duas vezes na mesma máquina.
    \item Não é possível interromper a execução de uma operação.
\end{itemize}


Na figuraX é possível ver um exemplo de uma instancia de problema de \textit{Job Shop}. A onde à duas maquinas $(M1, $ e $M2)$, dois \textit{jobs} $(J1, $ e $J2)$ e que cada \textit{job} possui duas operações $(Oj,1 $ e $Oj,2)$.\newline
Sendo assim:\newline
A $O1,1$ na maquina $M2$ tem o tempo de execução 9.\newline 
A $O1,2$ na maquina $M1$ tem o tempo de execução 5.\newline
A $O2,1$ na maquina $M1$ tem o tempo de execução 1. \newline
A $O2,2$ na maquina $M2$ tem o tempo de execução 7. \newline

\textit{\textbf{Inserir a figuraX aqui}}\newline
%% Fim do JSP %%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Problema de Job Shop Flexível - FJSP}


O \textit{Flexible Job Shop} é uma extensão do problema de \textit{Job Shop} em que é permitido que uma operação seja executada em mais de uma maquina. Então além de definir a ordem e a maquina de execução de cada \textit{job} também é preciso definir o agendamento das operações.\newline 
De um lado isso traz uma maior complexidade para o algoritmo, porém possibilita uma maior numero de possíveis soluções e deixa o algoritmo mais flexível para encontrar soluções. Mas por esse aumento de fatores a considerar o \textit{Flexible Job Shop} é considerado um problema mais complexo que o \textit{Job Shop}.\newline

Existem sub divisões no problema de \textit{FJSP}, sendo elas a \textbf{Parcial} (P-FJSP) se uma operação só pode ser processada por um certo sub conjunto de máquinas, ou \textbf{Total} (T-FJSP) caso uma operação possa ser processada por qualquer maquina.\newline

Para o \textit{Flexible Job Shop} são aplicadas as mesmas restrições do \textit{Job Shop} com exceção da que diz um \textit{job} não pode ser processado duas vezes em uma mesma maquina.\newline

%%%%%%%

\subsubsection{Instancia de um problema FJSP}
Na TabelaX é mostrado uma instancia de um problema de \textit{Flexible Job Shop} Total. Devido a sua flexibilidade a instancia de problema precisa informar quanto tempo cada maquina utilizaria para executar cada operação, logo uma instancia de um problema de \textit{Flexible Job Shop} é consideravelmente maior.\newline

A representação a seguir tem um exemplo de problema com dez maquinas $(M1, M2, M3, ..., M10)$ e
dez \textit{jobs} $(J1, J2, J3, ..., J10)$ e cada \textit{job} possuindo três operações $(Oj1, Oj2 e Oj3)$.\newline

Cada índice $ji$ da Tabelax representa o tempo $Tji$ de execução de execução de $Oji$, para cada máquina $Mk$, sendo $k = 1,... m$, onde $m$ é a quantidade de maquinas e $n$ a quantidade de jobs, ou seja, nesse exemplo $n = 10$ e $m = 10$.\newline
Então esse problema é de tamanho 10 x 10 como visto no benchmark de \cite{Kacem2002}.\newline

\textit{\textbf{Inserir a TabelaX aqui}}\newline

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Representações}
Para representar um solução para um problema de escalonamento é usado um gráfico de Gantt, demonstrando a maquina, tempo de inicio e tempo de termino de cada operação.\newline

Na FiguraX é possível ver um gráfico de Gantt para uma solução para o problema representado na TabelaX, que é um problema de \cite{Kacem2002} de tamanho 10 x 10. Nessa solução é possível se observar:
\begin{itemize}
    \item A máquina $M1$ executa as operações $[(O1,1), (O7,1), (O2,1)]$.
    \item Cada \textit{job} utiliza no minimo duas máquinas para ser executado, por exemplo: o $J1$ é executado nas máquinas $M1 , M3, M4$.
    \item O \textit{fitness} dessa solução é 7.
\end{itemize}

...\newline

\textit{\textbf{Inserir a TabelaX aqui}}\newline


\subsubsection{Cenários de Aplicação}
%% Onde da para usar e onde resolve problemas %%
\lipsum[3]

\section{Soluções Existentes}
%% Estado da arte e algoritmos que solucionam %%
\lipsum[3]

\subsection{Algoritmos Genéticos - GA}
%% Falar sobre GA %%
\lipsum[2]

%% TODO - Adicionar outras soluções existentes %%

%% Citar aqui no final o PSO %%

\section{Particle Swarm Optimization - PSO}
\lipsum[4]
%% Falar mais a fundo sobre o PSO %%

\subsection{Historia}
\lipsum[2]
%% Historia do PSO %%

\subsection{Aplicações}
\lipsum[3]
%% Aplicações do PSO %% 

\subsection{Defeitos e Problemas}
\lipsum[2]
%% Defeitos do PSO %%

\section{Melhorias do Algoritmo PSO}
\lipsum[2]
%% Falar de abordagens e melhorias no PSO %%

\subsection{Multithreading}
\lipsum[2]
%% Ambientes distribuídos %%

\subsection{Hiper Heurísticos}
\lipsum[2]
%% Utilização de Hiper Heurísticas para melhorar o PSO %%

\subsection{Hibridização}
\lipsum[2]
%% Sobre a possibilidade de usar GA no PSO %% 

%% TPSO, DIPSO, etc... %%
