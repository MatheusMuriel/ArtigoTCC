%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 1 ::: Introdução
\chapter{Introdução}
    Em um ambiente de produção industrial moderna a optimização é um ponto de grande importância, devido a constante mudança e alta concorrência. Em ramos como a manufatura isso se mostra especialmente importante, podendo ser o fator decisório para o sucesso de uma empresa \cite{Wari2016}.\newline

    Um dos exemplos de otimização dentro de sistemas de manufatura é dentro de um cenário onde existem diversas máquinas independentes e uma fila de tarefas não homogêneas, e o objetivo é achar uma programação de onde cada tarefa será executada e em qual ordem, de maneira a economizar o máximo de tempo e energia.\newline

    Em um ambiente de alta concorrência é importante que essa ordem seja encontrada o quanto antes, pois essa demora para encontrar a solução significa perda de tempo de produção. Porém a busca de um bom escalonamento, ou seja, a configuração e ordem de execução, não é uma tarefa fácil. Pois o número de possibilidades de arranjos cresce exponencialmente, e computar todas as soluções possíveis torna-se inviável após alguns níveis. \newline

    Por causa dessa característica exponencial de acordo com o número de máquinas e o número de problemas, esse problema de escalonamento é classificado como um problema de otimização de análise combinatória e pertence a classe de problemas \textit{NP-Hard}. \newline

    Os problemas da classe \textit{NP-Hard} são aqueles em que a resposta não pode ser encontrada computacionalmente em um tempo polinomial, ou seja, em um tempo razoável, porém uma solução pode ser verificada em tempo polinomial \cite{Eswaramurthy2008}.\newline

    Existem diversos problemas clássicos de produção e manufatura que são enquadrados em problemas de otimização e escalonamento, o que torna esse assunto uma área de muito interesse para pesquisadores do mundo inteiro.\newline

    Dentre os problemas clássicos de escalonamento e planejamento de produção estão: 
    \textit{Single Machine Scheduling Problem}, 
    \textit{Parallel Machine Scheduling Problem}, 
    \textit{Flow Shop Scheduling Problem}, 
    \textit{Job Shop Scheduling Problem} e 
    \textit{Open Shop Scheduling Problem} 
    \cite{Allahverdi2008}.\newline

    Como esses problemas não são possíveis de serem resolvidos em tempo polinomial, não é possível encontrar uma solução perfeita para eles. Mas é possível encontrarmos uma solução boa o suficiente, de acordo com os critérios de avaliação do problema, essa solução é chamada de solução ótima.\newline

    Job Shop Scheduling Problem (JSSP) é um do problema pertencente a classe de problemas \textit{NP-Hard}, ele chama muito a atenção de pesquisadores por ser um problema com diversas aplicações no mundo real, seja em ambientes de manufatura ou em planejamento de produção ou até mesmo em logística \cite{Cheng1996}.\newline

    Nesse problema, temos um conjunto $m$ de máquinas e um conjunto $n$ de tarefas chamadas de \textit{jobs}, sendo cada \textit{job} uma sequência de operações, cada uma com seu determinado tempo de execução. \newline 

    O objetivo é encontrar um escalonamento que combine todas as máquinas de forma que minimize a quantidade de tempo ocioso de cada máquina, assim atingindo o objetivos de forma mais econômica e eficiente \cite{Cheng1996}. \newline

    O problema de JSP é comprovadamente pertencente à classe \textit{NP-Hard} quando em um ambiente com duas ou mais máquinas, como demonstrado por \cite{Lenstra1979}. \newline

    Porém, assim como visto por \cite{Bagchi1999} existem algumas restrições no cenário de JSP, dentre elas:
    \begin{itemize}
        \item Duas operações do mesmo \textit{job} não podem ser executadas ao mesmo tempo;
        \item Nenhuma máquina pode executar simultaneamente mais de uma operação;
        \item As restrições e configurações de processamento são conhecidas previamente e não são alteradas;
        \item Todo \textit{job} deve ser processado até o fim, mas é permitido que haja pausas e esperas entre suas operações;
        \item As máquinas são homogêneas;
        \item Nenhum \textit{job} pode ser processado duas vezes na mesma máquina;
        \item As operações são atômicas, não sendo possível interromper ou pausar a execução da mesma;
    \end{itemize}

    O problema de Job Shop Flexível ou \textit{Flexible Job Shop Problem} (FJSP) é uma extensão do JSP onde é possível que uma operação seja executada em mais de uma máquina. Sendo assim deve se além de determinar a ordem e o local de execução de cada \textit{job}, também é preciso que seja determinada ordem e local de execução das operações. Assim sendo considerado uma extensão mais complexa do JSP \cite{Jansen2000}. \newline

    Além disso, o problema de FJSP pode ser dividido em dois tipos, o parcial (P-FJSP), onde uma operação só pode ser executada por um subconjunto de máquinas, ou o total (T-FJSP), onde qualquer operação pode ser executada por qualquer máquina. O FJSP tem as mesmas restrições do JSP exceto a que diz que nenhum \textit{job} pode ser processado duas vezes na mesma máquina. \newline

    Ao longo do tempo já foram propostas diversas abordagens para resolver o problema de FJSP, dentre elas o \textit{Branch and Bound} \cite{Nababan2008}, a 
    \textit{Integer Programming} \cite{Pan2007}, a 
    \textit{Dynamic Programming} \cite{Gromicho2012}, 
    \textit{Evolutionary Algorithm} \cite{Pezzella2008}, e até mesmo técnicas híbridas \cite{Zhang2009}, onde duas ou mais abordagens são associadas para compor um algoritmo híbrido. \newline

    Um desses algoritmos propostos é o algoritmo de Otimização por Enxame de Partículas ou \textit{Particle Swarm Optimization} (PSO) proposto por \cite{Kennedy1995} e trabalha com um grupo de indivíduos cada um tendo: direção, velocidade, a informação da sua melhor posição e a informação da melhor posição entre todos os indivíduos do grupo, e com essas informações cada indivíduo consegue tirar sua média e a cada rodada do algoritmo ir chegando mais perto do objetivo. \newline

    Outra abordagem que tem tido bons resultados em diversos problemas práticos \cite{Qing2012} são os Algoritmos Genéticos ou \textit{Genetic Algorithms} (GA), que foi proposto por \textit{John Henry Holland} e é inspirado na teoria da evolução de Charles Darwin, simulando a transmissão de genes dos indivíduos mais aptos por meio da simulação de operações de cruzamento e de mutações, de forma a selecionar os indivíduos mais aptos. \newline

    Neste trabalho iremos demonstrar e comparar a eficiência de uma abordagem híbrida do Algoritmo PSO com componentes evolutivos de GA, tornando assim esse algoritmo mais dinâmico, além de demonstrar sua eficiência em diferentes cenários reais de aplicação na indústria.\newline
%% Fim da [Introdução] %%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 1 ::: Introdução
%% 1.1
\section{Problemas de Agendamento}
    %% Interludio do [Problemas de Agendamento] %%
        Problemas de agendamento estão muito presentes nos dias atuais, e existem diretamente em diversos cenários, tais como planejamento de produção, sistemas de manufatura, sistemas de produção, processamento de informação, gerenciamento de rotas de logísticas e etc... e indiretamente nos computadores através do escalonamento de processos do sistema operacional.\newline

        Com tantos possíveis cenários de aplicação é natural que existam inúmeras sub-divisões deste problema. Porém a maioria deles tem características em comum. No geral eles se baseiam em um conjunto de recursos e um conjunto de demandas, e tem como objetivo ordenar as execuções das demandas e as distribuir entre os recursos, isso afim de alcançar da melhor possível um ou mais objetivos, que podem ser por exemplo o tempo total para o algoritmo executar o agendamento (também chamado de \textit{makespan}), o tempo total de execução de todas as tarefas no agendamento encontrado (também chamado de \textit{fitness}) ou a soma total do tempo de ociosidade das maquinas.\newline

        Por essa característica de buscar um melhor resultado em um objetivo os problemas de agendamento são caracterizados como problemas de optimização, que são os problemas que a solução são aquelas que trazem um melhor resultado para o objetivo. É importante ressaltar que nesses problemas de optimização a solução não necessariamente precisa a melhor possível, mas sim uma solução boa o suficiente (também chamado de solução ótima).\newline

        Os problemas de agendamento multi-objetivo consideram ao mesmo tempo mais de um critério de avaliação, podendo ter ou não o mesmo peso ou nível de importância, e espera se que sejam atingidos todos os objetivos. Por causa dessa diversidade de objetivos que podem muitas vezes serem conflitantes entre si, como por exemplo ser mais rápido e ao mesmo tempo gastar a menor quantidade possível de energia.\newline

        Já os problemas de agendamento mono-objetivo lidam somente com um critério de avaliação, o que diminui significativamente a dificuldade para encontrar um solução, porém em contra partida define uma importância maior para o objetivo em questão, sendo necessário um maior nível de refinamento da solução.
    %% Fim do Interludio do [Problemas de Agendamento] %%

    %% 1 ::: Introdução
    %% 1.1 ::: Problemas de Agendamento
    %% 1.1.1
    \subsection{Definição}
        Como foi definido por \cite{Bagchi1999} um problema de escalonamento de tarefas computacionais (\textit{jobs}) é um problema de otimização aonde os recursos limitados são alocados no tempo de execução dos recursos, com as diferentes tarefas podendo ser executadas em paralelo entre as diversas maquinas, porém cada atividade única sendo executada sequenciamento em uma só maquina.\newline

        Assim como a grande maioria dos problemas de origem combinatória, ou seja que um fator depende o fator anterior, formando assim uma combinação de fatores, o problema de escalonamento é um problema da classe NP-Hard da qual não é possível se encontrar a melhor solução possível em um tempo polinomial, ou seja, computacionalmente aceitável, devido a sua quantidade de operações necessárias crescer exponencialmente, com base no tamanho do problema, tornando se assim um problema inviável de se resolver através de cálculos brutos.\newline

        Por causa disso nesses casos de problemas NP-Hard normalmente se usam algoritmos de aproximação, que tenham um tempo de execução razoável e que consigam encontrar uma solução boa o suficiente com base nos critérios de avaliação, a chamada "Solução Ótima", como visto por \cite{Lawler1993}.\newline

        Porém esse conceito de solução ótima varia de acordo com o problema, em alguns casos é mais importante que essa solução seja encontrada em um tempo curto, do que ela seja alguns milissegundos mais rápida do que as outras soluções já encontradas, isso se aplica em ambientes que o agendamento deve ser feito em tempo real.\newline
        Já para um problema em que essa solução precisa ser encontrada apenas uma vez e ser replicada varias vezes, como uma estrutura de linha de montagem definitiva, vale a pena esperar algumas horas a mais se essa solução economizar tempo de produção ao longo do seu uso. Então esse critério de avaliação de solução ótima deve ser muito bem analisado de caso a caso. \newline

        Nesses ambientes de soluções aproximadas, alguns algoritmos que se destacam são os algoritmos bio inspirados, algoritmos populacionais e algoritmos evolutivos. Que são capazes de simular uma inteligencia biológica ou comportamentos já observados na natureza e selecionados pela evolução para encontrar uma solução ótima, de maneira similar a que um ser vivo faria.
    %% Fim do [Definição] %%


    %% 1 ::: Introdução
    %% 1.1 ::: Problemas de Agendamento
    %% 1.1.2
    \subsection{Variações}
        Diversos autores já classificaram diversas variações de problemas de escalonamento dentre eles \cite{graham1979}, \cite{Lenstra1979}, e \cite{maccarthy1993}. O que diferencia os problemas são o fluxo dos \textit{jobs} a serem processados e a capacidade dos recursos. Dentre esses problemas estão:
        \begin{itemize}
            \item \textbf{\textit{Open Shop:}} Os \textit{job} tem uma ordem de execução, porém as operações de cada \textit{job} tem uma ordem específica de execução.
            
            \item \textbf{\textit{Flow Shop:}} Os \textit{jobs} devem ser executados em um fluxo unidirecional e em uma maquina somente. E não exite uma divisão do \textit{jobs} em operações.
            
            \item \textbf{\textit{Flexible Flow Shop:}} Semelhante ao \textit{Flow Shop}, porém os \textit{jobs} podem ser divididos em operações.
            
            \item \textbf{\textit{Job Shop:}} Diferentemente do \textit{Flow Shop} o \textit{Job Shop} pode ter execuções paralelas, assim como ser dividido em operações.
            
            \item \textbf{\textit{Flexible Job Shop:}} Uma extensão do \textit{Job Shop} em que as operações de cada \textit{Job} podem ser executados em maquinas diferentes. Esse problema tem duas sub divições, a Total, em que todas as maquinas podem executar todas as operações. E a Parcial, na qual existem limitações para quais maquinas podem executar quais operações.
        \end{itemize}

        Além disso cada um dos problemas acima podem ser sub-classificados como mono-objetivos ou multi-objetivos de acordo com os tipos e a quantidade de obejtivos. \newline
        No caso de ter somente um unico objetivo, como um menor \textit{fitness} por exemplo, ou ter mais de um objetivo, como um menor \textit{fitness} e um menor indice de inercia total.\newline

        Esse trabalho é focado no problema de \textit{Flexible Job Shop} Total, em um contexto mono-objetivo.
    %% Fim do [Problema] %%


    %% 1 ::: Introdução
    %% 1.1 ::: Problemas de Agendamento
    %% 1.1.3
    \subsection{Problema de Job Shop - JSP}
        %% Interludio do [Problemas de Agendamento] %%
            Como citado anteriormente o \textit{Job Shop Problem} (JSP) é um problema de escalonamento de tarefas e pertence a classe de problemas NP-Hard. Como visto por \cite{Cheng1996} o problema de \textit{Job Shop} chama muita atenção por ser um problema com diversas aplicações no mundo real, e em diversos cenários diferentes, como industria, computação e manufatura.\newline

            De acordo com \cite{Cheng1996} o problema de \textit{Job Shop} consiste em $m$ máquinas distintas e $n$ \textit{jobs} diferentes, sendo cada \textit{job} formado por diversas operações $O$ em uma ordem especifica. Cada operação $Oij$ tem seu respectivo tempo de execução.\newline

            Como visto por \cite{Bagchi1999} existem algumas restrições no problema de \textit{Job Shop} dentre elas:
            \begin{itemize}
                \item Mais de uma operação de um mesmo \textit{job} não pode ser executada ao mesmo tempo.
                \item Não existe mais de uma maquina de um mesmo tipo.
                \item As máquinas podem ficar ociosas durante o período de escalonamento.
                \item As execuções de \textit{jobs} são atômicas, ou seja cada \textit{job} deve ser processado até o fim.
                \item Uma máquina não pode executar mais de uma operação simultaneamente.
                \item Um \textit{job} não é processado duas vezes na mesma máquina.
                \item Não é possível interromper a execução de uma operação.
            \end{itemize}
        %% Fim do Interludio do [Problemas de Agendamento] %%
        
        %% 1 ::: Introdução
        %% 1.1 ::: Problemas de Agendamento
        %% 1.1.3 ::: JSP
        %% 1.1.3.1
        \subsubsection{Representações}
            Para que seja possivel que um algoritmo encontre uma solução para o agendamento, ele precisar conhecer algumas informações, dentre elas: 
            \begin{itemize}
                \item Quantas maquinas existem;
                \item Quantos \textit{Jobs} existem;
                \item Quantas operações cada \textit{Job} posui;
                \item Em qual maquina cada operação pode ser executada;
                \item Quanto tempo cada operação leva para ser executada em sua respectiva maquina;
            \end{itemize}
        %% Fim do [Representações] %%


        %% 1 ::: Introdução
        %% 1.1 ::: Problemas de Agendamento
        %% 1.1.3 ::: JSP
        %% 1.1.3.1 ::: Representações
        %% 1.1.3.1.1
        \subsubsubsection{Instancia de um Problema}
            Na figuraX é possível ver um exemplo de uma instancia de problema de \textit{Job Shop}. A onde à duas maquinas $(M1, $ e $M2)$, dois \textit{jobs} $(J1, $ e $J2)$ e que cada \textit{job} possui duas operações $(Oj,1 $ e $Oj,2)$.\newline
            Sendo assim:\newline
            A $O1,1$ na maquina $M2$ tem o tempo de execução 9.\newline 
            A $O1,2$ na maquina $M1$ tem o tempo de execução 5.\newline
            A $O2,1$ na maquina $M1$ tem o tempo de execução 1. \newline
            A $O2,2$ na maquina $M2$ tem o tempo de execução 7. \newline

            \textit{\textbf{Inserir a figuraX aqui}}\newline
        %% Fim do [Instancia de um Problema] %%

     %%
    %% Fim do [JSP] %%


    %% 1 ::: Introdução
    %% 1.1 ::: Problemas de Agendamento
    %% 1.1.4
    \subsection{Problema de Job Shop Flexível - FJSP}
        %% Interludio do [FJSP]%%
            O \textit{Flexible Job Shop} é uma extensão do problema de \textit{Job Shop} em que é permitido que uma operação seja executada em mais de uma maquina. Então além de definir a ordem e a maquina de execução de cada \textit{job} também é preciso definir o agendamento das operações.\newline 
            De um lado isso traz uma maior complexidade para o algoritmo, porém possibilita uma maior numero de possíveis soluções e deixa o algoritmo mais flexível para encontrar soluções. Mas por esse aumento de fatores a considerar o \textit{Flexible Job Shop} é considerado um problema mais complexo que o \textit{Job Shop}.\newline

            Existem sub divisões no problema de \textit{FJSP}, sendo elas a \textbf{Parcial} (P-FJSP) se uma operação só pode ser processada por um certo sub conjunto de máquinas, ou \textbf{Total} (T-FJSP) caso uma operação possa ser processada por qualquer maquina.\newline

            Para o \textit{Flexible Job Shop} são aplicadas as mesmas restrições do \textit{Job Shop} com exceção da que diz um \textit{job} não pode ser processado duas vezes em uma mesma maquina.\newline
        %% Fim do Interludio do [FJSP]%%

        %% 1 ::: Introdução
        %% 1.1 ::: Problemas de Agendamento
        %% 1.1.4 ::: FJSP
        %% 1.1.4.1
        \subsubsection{Representações}
            As representações do \textit{Flexible Job Shop} são praticamente as mesma do \textit{Job Shop} com exeção da representação do problema, devido a sua natureza flexivel uma representação do \textit{Flexible Job Shop} precisa definir quanto tempo cada maquina utilizaria para procesar cada operação. Porém no caso de uma problema de \textit{Flexible Job Shop} Parcial, ou seja, em que uma operação não pode ser processada por qualquer maquina, a representação não precisa definir o tempo de processamento de todas as operações para todas as maquinas, mas somente para as maquinas que podem processar aquela operação
        %% Fim do [Representações] %%


        %% 1 ::: Introdução
        %% 1.1 ::: Problemas de Agendamento
        %% 1.1.4 ::: FJSP
        %% 1.1.4.1 ::: Representações
        %% 1.1.4.1.1
        \subsubsubsection{Instancia de um Problema}
            Na TabelaX é mostrado uma instancia de um problema de \textit{Flexible Job Shop} Total. Devido a sua flexibilidade a instancia de problema precisa informar quanto tempo cada maquina utilizaria para executar cada operação, logo uma instancia de um problema de \textit{Flexible Job Shop} é consideravelmente maior.\newline

            A representação a seguir tem um exemplo de problema com dez maquinas $(M1, M2, M3, ..., M10)$ e dez \textit{jobs} $(J1, J2, J3, ..., J10)$ e cada \textit{job} possuindo três operações $(Oj1, Oj2 e Oj3)$.\newline

            Cada índice $ji$ da Tabelax representa o tempo $Tji$ de execução de execução de $Oji$, para cada máquina $Mk$, sendo $k = 1,... m$, onde $m$ é a quantidade de maquinas e $n$ a quantidade de jobs, ou seja, nesse exemplo $n = 10$ e $m = 10$.\newline
            Então esse problema é de tamanho 10 x 10 como visto no benchmark de \cite{Kacem2002}.\newline

            \textit{\textbf{Inserir a TabelaX aqui}}\newline
        %% Fim do [Instancia de um Problema] %%


        %% 1 ::: Introdução
        %% 1.1 ::: Problemas de Agendamento
        %% 1.1.4 ::: FJSP
        %% 1.1.4.1 ::: Representações
        %% 1.1.4.1.2
        \subsubsubsection{Solução}

            Na FiguraX é possível ver um gráfico de Gantt para uma solução para o problema representado na TabelaX, que é um problema de \cite{Kacem2002} de tamanho 10 x 10. Nessa solução é possível se observar:
            \begin{itemize}
                \item A máquina $M1$ executa as operações $[(O1,1), (O7,1), (O2,1)]$.
                \item Cada \textit{job} utiliza no minimo duas máquinas para ser executado, por exemplo: o $J1$ é executado nas máquinas $M1 , M3, M4$.
                \item O \textit{fitness} dessa solução é 7.
            \end{itemize}

            ...\newline

            \textit{\textbf{Inserir a TabelaX aqui}}\newline
        %% Fim do [Solução] %%


        %% 1 ::: Introdução
        %% 1.1 ::: Problemas de Agendamento
        %% 1.1.4 ::: FJSP
        %% 1.1.4.2
        \subsubsection{Cenários de Aplicação}
            O exemplo mais claro de oplicação do problema de \textit{Flexible Job Shop} é em produção industrial e em sistemas de manufatura, o que tras muito interesse economico para boas soluções para esse tipo de problema.\newline
            Como visto por \cite{Wari2016} nos tempos modernos em que à uma grande competição e constante melhorias tecnologicas, a organização e otimização desses processos processos industriais se torna um gargalo a ser resolvido e pode ser um fator decisório no sucesso de uma industria.
        %% Fim do [Cenários de Aplicação] %%
        
     %%
    %% Fim do [FJSP] %%
    
 %%
%% Fim do [Problemas de Agendamento] %%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 1 ::: Introdução
%% 1.2
\section{Soluções Existentes}
    %% Interludio %%
        Ao longo do tempo foram propostas, testestadas, revisadas e aprimoradas diversas soluções para os problemas de agendamento, e como cada cenario de aplicação é diferente não é possivel definir qual solução é a melhor, pois isso depende de caso a caso, contudo, durante o tempo varias soluções se destacaram como mais eficientes e adaptaveis a novas demandas, cenarios e objetivos. \newline
        
        Um tipo de solução muito recorente são as baseadas em comportamento biologico. Ao longo de milhões de anos a vida biologica no planeta terra evoloiu e se adaptou para encontrar o mode mais eficiente de resolver os diversos problemas que a natureza os impõe. Então observando esses comportamentos adaptativos, foram propóstos diversos algoritmos como os algoritmos populacionais que simulam como populações, como por exemplo bandos de avés, enchames de abelhas ou colonias de formigas usam o comportamento de bando para solucionar um problema como o de encontrar alimento, ou fugir de predadores. Ou algoritmos que simulam as proprias regras de seleção natural para evoluir individos de uma população para gerar e acumular mutações para achar um individuo mais adaptado e solucionar o problema, esses são os algoritmos geneticos e algoritmos evolutivos.
    %% Fim do Interludio %%


    %% 1 ::: Introdução
    %% 1.2 ::: Soluções Existentes
    \subsection{Algoritmos Evolutivos}
        Os Algoritmos Evolutivos são baseados no mecanismo de seleção natural que é observado na natureza. Então um individo que tem alguma caracteristica que o destaque tem maior chance de se reproduzir e transmitir essa caracteristica para os seus descendentes.\newline
        A estrutura basica de um algoritmo evolutivo é:
        \begin{enumerate}
            \item Inicialização da população;
            \item Analise da qualidade de cada individo;
            \item Seleção dos melhores individos;
            \item Cruzamento desses individos afim de gerar uma nova população;
            \item Repetição apartir do passo 2;
        \end{enumerate}
        Essa estrutura se repete até que seja atingido o criterio de parada estabelecido pelo problema em questão.\newline
        Além da estrutura basica é possivel melhorar um algoritmo evolutivo atraves de um aprendizado continuo, ou seja, em um ambiente no qual tenha mudanças constantes um algoritmo evolutivo pode se adaptar e assim se auto melhorar sem a necessidade de uma intervação do programador.
    %% Fim do [Alg EV] %%


    %% 1 ::: Introdução
    %% 1.2 ::: Soluções Existentes
    \subsection{Algoritmos Genéticos}
        Uma derivação dos algoritmos evolutivos são os algoritmos geneticos, que são utilizados para buscas e para otimizações, como nos problemas de escalonamento. Essa abordagem chama atenção por conseguir lidar com uma grande diversidade de soluções, o que a torna interessante especialmente em problemas de multi-objetivo como visto por \cite{Bagchi1999}.\newline
        
        Os algoritmos geneticos são com certeza a abordagem mais utilizada dentre os algoritmos evolutivos, o que algumas vezes pode gerar a impressão de que algoritmos geneticos e evolutivos são a mesma coisa, porém como o algoritmo genetico lida com uma simulação de cromossomos isso o faz com que suas estruturas sejam muito mais dinamicas, enquanto as tecnicas de algoritmos evolutivos tem estruturas mais fixas.\newline
        Para ter essa dinamissidade os algoritmos geneticos trabalham com o conceito de mutações aleatorias, que podem ou não serem boas para o individuo, porém, por ser uma derivação dos algoritmos evolutivos o algoritmo genetico conta também com os mecanismos de seleção e cruzamento da população, o que tende a selecionar apenas os individuos com mutações que são positivas do ponto de vista do objetivo estabelecido.
    %% Fim do [GA] %%


    %% 1 ::: Introdução
    %% 1.2 ::: Soluções Existentes
    \subsection{Algoritmos Populacionais}
        Uma outra abordagem dos algoritmos bioinspirados são os algoritmos populacionais, em que normalmente não se é utilizado tecnicas de evolução do individos especificos, mas o foco é dado no comportamento da população.\newline
        Seus cenarios de aplicação vão além dos algoritmos de otimização e também são utilizados em algoritmos de busca e em efeitos visuais, sendo amplamente utilizada em filmes. \newline
        
        Os algoritmos populacionais usam o conceito de inteligencia de bando, no qual idividos simples interagem entre si e com o ambiente e juntos convergem para uma solução.\newline
        A inteligencia de bando pode ser vista em diversos lugares da natureza, como em colonias de formigas, enxames de abelhas, na forma de voo migratorio de avés, na forma de casa de avés predatorias como aguias, na organização de cardumes de peixes.\newline

        O que torna essa abordagem interessante é a sua caracteristica decentralizada e de auto organização, o que a torna mais extendivel e adaptavel a cenarios distribuidos. Um exemplo da utilização de algortimos populacionais é na auto organização de drones e robos, que são definidas como \textit{Swarm Robotics}. Fazendo assim com que por se algum robo tiver um defeito isso não afete a organização do grupo. \newline
        Dentre os principais algoritmos populacionais estão:
        \begin{itemize}
            \item Optimização por Colonia de Formigas (\textit{Ant Colony Optimization}) 
            \item Difusão Estocastica de Busca (\textit{Stochastic Diffusion Search})
            \item Optimização por Enchame de Particulas (\textit{Particle Swarm Optimization})
        \end{itemize}
        
        Todos eles se baseiam em como a população de individos encontram juntos um objetivo. Nesse trabalho é utilizado o algoritmo de Optimização por Enxame de Particulas. 
    %% Fim do [Algoritmos Populacionais] %%

 %%
%% Fim do [Soluções Existentes] %%

%% 1 ::: Introdução
%% 1.3
\section{Particle Swarm Optimization - PSO}
    %% Interludio %%
        O algoritmo de Optimização por Enxame de Particulas ou PSO da sigla em ingles para (\textit{Particle Swarm Optimization}) é um algoritmo baseado nas teorias de inteligencia de enxame. E diferentemente de outros algoritmos baseados em populações, como o \textit{Ant Colony Optimization} o \textit{Particle Swarm Optimization} é baseado em uma população generica de individuos, embora normalmente sejam ilustrados como uma população de avés.
    %% Fim do [Interludio] %%


    %% 1 ::: Introdução
    %% 1.3 ::: PSO
    %% 1.3.1
    \subsection{Historia}
        O algoritmo \textit{Particle Swarm Optimization} for proposto por \cite{Kennedy1995} e desde então tems e mostrado muito promisor para a solução de diversos problemas de optimização. Por ser um algoritmo bem simples e flexivel, ao longo do tempo jpa foram propostas varias variações para ele. \newline
        
        Porém o \textit{Particle Swarm Optimization} ja foi alvo de varias discuções na area pois alguns autores discordam de ele ser classividade como parte dos algoritmos evolutivos, pois embora haja variações que sim, o \textit{Particle Swarm Optimization} original não implementa mecanismos de seleção, cruzamento e mutação, que são criterios base para os algoritmos evolutivos. \newline
        Atualmente o \textit{Particle Swarm Optimization} é classificado como parte da familia dos algoritmos de \textit{Swarm Intelligence}.
    %% Fim do [Historia] %%


    %% 1 ::: Introdução
    %% 1.3 ::: PSO
    %% 1.3.2
    \subsection{Definição}
        A definição basica do algoritmo \textit{Particle Swarm Optimization} é uma população de particulas (também chamadas de individuos), em que cada particula tem uma velocidade e uma direção, além das informações da sua posição, qual é a qualidade de sua posição, qual foi a melhor posição na qual ela já esteve, e acesso a um conhecimento compartilhado entre todos os individuos com a melhor posição em que qualquer um deles já esteve. E assim a cada rodada as particulas se movimentam com base na sua melhor posição e na melhor posição geral, e assim a cada rodada a população converge para uma solução otima.\newline
        
        As variaveis mais importantes do PSO são justamente as melhores posições, sendo a local normalmente chamada de $pBest$ e a geral normalmente chamada de $gBest$. Elas vão ser utilizadas para obter uma media que será a nova posição da particula. Porém existem resistencias para que a particula mude de direção, isso acontece por meio da inercia normalmente representada por $w$ que representa a força que tende a fazer a particula seguir a direção na qual ela já está se movendo. Essa força de inercia cresce de acordo com o valor de velocidade da particula normalmente representado por $v$, ou seja, particulas com uma maior velocidade ($v$) tendem a tem uma maior inercia ($w$).\newline
        
        No pseudocodigoX é possivel uma representação de um algoritmo PSO basico, esse algoritmo tem como base a formulação de \cite{martinez2009}.
        
        \textit{inserir o pseudocodigoX aqui}

        Na definição base do algoritmo não existe uma especcificação de uma formula para o calculo da movimentação da particula. Porém na formulaX é posivel ver uma representação de uma formula base para o calculo de uma nova posição para a particula.

        \textit{inserir a formulaX aqui}

     %%
    %% Fim do [Definição] %%
    

    %% 1 ::: Introdução
    %% 1.3 ::: PSO
    %% 1.3.4
    \subsection{Problemas}
        Alguns cuidados devem ser tomados para a implementação do \textit{Particle Swarm Optimization} pois o algoritmo se mal configurado atravez dos parametros de velocidade, inercia e tamanho da população, tende a convergir prematuramente para uma solução não otima, esse problema é normalmente chamado de "Convergencia Prematura".\newline
        
        Algumas medidas podem ser tomadas para diminuir essa posibilidade de convergencia Prematura, como valores dinamicos de inercia e uma ponderação nos valor de importancia de $pBest$ e $gBest$.
    %% Fim do [Problemas] %%


    %% 1 ::: Introdução
    %% 1.3 ::: PSO
    %% 1.3.5
    \subsection{Melhorias}
        %% Interludio %%
            Algumas tecnicas podem ser usadas para melhorar o desenpenho do PSO em cada cenario de aplicação. Porém o efeito dessas abordagens varia de acordo com qual problema esta sendo resolvido e dos recursos e limitações de processamento e memoria do ambiente de processamento do algoritmo.
        %% Fim do [Interludio] %%

        \subsubsection{Multithreading}
            Uma abordagem que tem bons resultados é o processamento distribuido do calculo de cada particula como visto por \cite{Thongkrairat2019} e \cite{Kim2011}. Essa paralelização é possivel graças a natureza distribuida dos algoritmos populacionais. No caso do \textit{Particle Swarm Optimization} o unico fator a se levar em consideração para uma implementação distribuida é a atualização da variavel $gBest$.\newline
            
            Um cenario que tira um bom proveito dessa abordagem são os de robos e drones.            
        %% Fim do [Multitheading] %%

        \subsubsection{Hibridização}
            %\lipsum[2]
            %% Sobre a possibilidade de usar GA no PSO %% 
        %% Fim do [Hibridização] %%

     %
    %% Fim do [Melhorias] %%

 %
%% Fim do [PSO] %%

