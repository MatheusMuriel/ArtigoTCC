%% 2 ::: Desenvolvimento
\chapter{Desenvolvimento}
%% Interlúdio do [Desenvolvimento] %%
    Nesse capítulo são descritos os métodos e técnicas utilizadas no desenvolvimento tanto do algoritmo PSO com a nova abordagem proposta quanto da abstração para o problema de FJSP. Também são descritos os critérios de parada escolhidos e modo de execução e os resultados dos testes.
%% Fim do Interlúdio do [Desenvolvimento] %%


%% 2 ::: Desenvolvimento
%% 2.1
\section{Metodologia de Pesquisa}
%% Interlúdio do [Metodologia de Pesquisa] %%
Para os testes deste trabalho estão sendo usados os mesmo problemas utilizados por \cite{Kacem2002}, e já são largamente usados na literatura. Sendo representados por $[j, o, m]$ em que $j$ é a quantidade de \textit{jobs}, $o$ é a quantidade de operações e $m$ a quantidade de máquinas. Para observar o comportamento do algoritmo em diversos cenários foram escolhidos problemas de tamanhos variados, sendo eles $[4, 12, 5]$, $[10, 29, 7]$, $[10, 30, 10]$ e $[15, 56, 10]$.\\
%
\indent Os algoritmos foram executados no ambiente de nuvem Google Colab Code sendo executado no motor \textit{Python 3 Google Compute Engine Backend}. Para a execução foi utilizado um \textit{runtime} com processadores comuns (CPU) e 12 Gigabytes de memória RAM.\\
%
%
\indent Para que possibilitar uma análise de dados mais detalhada e a geração de gráficos para representação nesse trabalho, foram implementados no código pontos de salvamento de dados, para salvar em formato de binários do NumPy, utilizando a função \code{np.savedata}, as informações de execuções e de datasets.\\
\indent Dentre esses dados estão o espaço de soluções gerado, a quantidade de rodadas realizadas, o histórico da variável $gBest$, o número de mudanças de $pBest$, o histórico de posição das partículas e as soluções finais encontradas.
%% Fim do Interlúdio do [Metodologia de Pesquisa] %%

%% 2 ::: Desenvolvimento
%% 2.1 ::: Metodologia de Pesquisa
%% 2.1.1

%% 2 ::: Desenvolvimento
%% 2.2
\section{Arquitetura}
%% Interlúdio do [Arquitetura] %%
A arquitetura de um projeto de é um fator que impacta diretamente no seu desempenho, porém como o objetivo desse trabalho é entender como o algoritmo PSO se comporta diante das alterações propostas, foi necessário o desenvolvimento de uma arquitetura que represente o problema de maneira mais abstrata.
%% Fim do Interlúdio do [Arquitetura] %%

%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.1
\subsection{Design do Projeto}
Por esse trabalho ser desenvolvimento dentro de um grupo de estudos, foi optado por usar uma estrutura de projeto mais didática e de fácil entendimento, de maneira que possa ser facilmente reutilizada por futuros estudantes. Porém, essa escolha acarreta uma certa perda de desempenho, porém, como se trata de um trabalho que visa explorar como cada tipo de alteração impacta o algoritmo, essa perca de desempenho não se torna um defeito.\\
\indent O projeto foi desenvolvido na linguagem de programação Python versão 3.9.7 e utiliza além das bibliotecas básicas da linguagem, as bibliotecas:
\begin{itemize}
    \item NumPy (versão 1.21.3)
    \item MatPlotlib (versão 3.4.3)
\end{itemize}

\noindent O MatPlotlib foi utilizado para a geração de: 
\begin{itemize}
    \item Gráficos de Dispersão (\textit{Scatter Plot}) para representar a posição das partículas da população.
    \item Gráficos de Superfície (\textit{Surface Plot}) para representar o espaço de soluções.
    \item Gráficos de Barra Horizontal (\textit{Horizontal Bar Plot}) para representar um diagrama de Gantt com a solução do agendamento.
\end{itemize}

\noindent O NumPy foi utilizado para: 
\begin{itemize}
    \item Grandes arranjos multi dimensionais de dados. 
    \item Funções randômicas de escolha.
    \item Ordenação de dados.
    \item Operações de cálculo como raiz quadrada e potenciação.
    \item Funções de escolha de valores máximos e mínimos.
    \item Modelagem, união e remodelagem de matrizes.
    \item Representações e calculo de vetores de movimentação.
\end{itemize}
        
Para trazer mais clareza ao código foi optado por criar algumas classes para a representação de entidades e abstração de lógicas. Dentre elas estão:
\begin{itemize}
    \item Classe de Partícula, que faz a representação de uma entidade de partícula e armazena sua posição, velocidade e direção. Faz a inicialização da partícula com valores aleatórios de posição, velocidade e direção. E estabelece métodos para calcular o movimento da partícula e o valor da qualidade de sua nova posição.

    \item Classe de \textit{encoding}, responsável por ler e interpretar os arquivos de instância de um problema, criar uma representação para de solução, e então gerar o espaço de soluções com soluções geradas aleatoriamente.

    \item Classe de \textit{decoding}, responsável por decodificar uma solução no padrão de representação estabelecido pela classe de \textit{encoding} e calcular o \textit{fitness} dessa solução. Essa classe também estabelece o método que gera o gráfico de Gantt para representar visualmente a solução.
\end{itemize}

\indent Como o PSO é um algoritmo estocástico, ou seja, seu resultado é fruto de eventos não previsíveis foi decidido que para obter uma média real dos desempenhos de cada algoritmo, em cada uma das 30 execuções será gerado um novo espaço de soluções e uma população inicial diferente.\\
\indent E em cada uma dessas execuções será passado para cada um dos algoritmos uma \textit{deepcopy} do espaço de soluções e da população inicial, para que os diferentes algoritmos trabalhem com base nos mesmos dados iniciais, para assim tem uma análise mais justa.\\
\indent Para que a análise dos dados possa ser feita mais detalhadamente, foram implementados alguns pontos de salvamento de dados, para salvar em arquivo texto as representações da população e do espaço de soluções gerados aleatoriamente, assim como a quantidade de rodadas realizadas, o histórico da variável $gBest$, o número de mudanças de $pBest$, o histórico de posição das partículas e as soluções finais encontradas.
%
%% Fim do [Design do Projeto] %%
    

%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.2
\subsection{Espaço de Soluções}
%% Interlúdio %%
O espaço de soluções (também chamado espaço de busca) é um conceito que define um espaço imaginário aonde cada ponto desse espaço é uma possível solução para o problema em questão. 
Um espaço de soluções pode ser representado de diversas maneiras, como listas e grafos, mas em problemas de optimização normalmente se usa uma representação na forma de uma matriz.\\
%% Fim do [Interlúdio] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.2 ::: Espaço de Soluções
%% 2.2.2.1
%\subsubsection{Representações}
\indent Nessa representação em forma de matriz cada localização $[i, j]$ tem uma solução valida para o problema, e o algoritmo em questão tem a tarefa de encontrar qual dessas posições tem a melhor solução, ou uma solução boa o suficiente. Na 
\hyperref[fig:solution-space]{Figura \ref{fig:solution-space}} 
é mostrado uma representação conceitual criada para ilustrar um espaço de soluções em forma de matriz.\hfill
            
\begin{figure}[ht]
    \centering
    \caption{Representação de uma matriz de espaço de soluções}
    \label{fig:solution-space}
    \includegraphics[width=\textwidth]{assets/solution.png}
    %\small{Incluir a imagem do exemplo de espaço de solução aqui}
\end{figure}

Algumas das implementações encontradas em bibliotecas de algoritmos populacionais de código aberto como \textit{PySwarms} utilizam internamente um sistema de representação de espaço de soluções de uma única dimensão, ou seja, uma lista simples, e utiliza uma função para transformar uma posição $[x,y]$ em um índice da lista. Essa implementação provavelmente foi escolhida por ser geralmente, mais rápida em comparação a uma abordagem de duas dimensões.\\
%% Fim do [Representações] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.2 ::: Espaço de Soluções
%% 2.2.2.2
%\subsubsection{Gráficos de análise}
\indent Como esse trabalho tem como foco uma exploração e implementação mais didática foi optado a utilização de uma representação em forma de uma matriz com duas dimensões, utilizando a biblioteca \textit{NumPy}. Essa abordagem em matriz de duas dimensões também facilita a geração de gráficos para representação visual, como, por exemplo, passar a matriz de soluções pela função de avaliação e assim obter um valor de \textit{fitness} para cada ponto do espaço de soluções, como é possível ver na 
\hyperref[fig:surfaceplot]{Figura \ref{fig:surfaceplot}} 
na qual os valores mais acima e mais escuros tem um valor de \textit{fitness} mais alto (ou seja, pior), e os valores mais abaixo e mais claros tem um \textit{fitness} mais baixo (ou seja, melhor).

\begin{figure}[ht]
    \centering
    \caption{Gráfico de Superfície representando um espaço de soluções}
    \label{fig:surfaceplot}
    \includegraphics[width=\textwidth]{assets/surfaceplot.png}
\end{figure}

Esses gráficos se mostraram úteis ao decorrer do desenvolvimento deste trabalho, servindo para validar detectar erros na função de inicialização do espaço de soluções.\\
%% Fim do [Gráficos de Analise] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.2 ::: Espaço de Soluções
%\subsubsection{Influencia na Solução}
\indent A geração do espaço de soluções é muito importante para algoritmos como o PSO 
que funciona com base na movimentação conforme as médias de melhores posições, 
devido a isso, o PSO tente a ter problemas com convergência prematura em mínimos locais.\\
\indent Os mínimos locais são fenômenos onde dentro de uma parte do espaço de soluções existe um ponto que é melhor que a média dos pontos a sua volta, porém não é o melhor entre o todo o espaço de soluções, como é possível ver na \hyperref[fig:ex-minimolocal]{Figura \ref{fig:ex-minimolocal}}.\newline
\begin{figure}[ht]
    \centering
    \caption{Exemplo de um mínimo local}
    \label{fig:ex-minimolocal}
    \includegraphics[width=\textwidth]{assets/minimo_local.png}
    %\small{}
\end{figure}
Por esse ponto se destacar entre seus vizinhos o algoritmo pode ficar preso nesta região, pois a média local sempre tende para o ponto onde está o mínimo local.\\
Como o PSO se baseia na média local e global, se houver mais de um mínimo local e quantidades equivalentes de partículas da população forem distribuídas para esses pontos, as partículas podem ficar presas já que as forças se balanceiam e o $gBest$ não muda mais.\\
%
\indent Já a convergência prematura acontece quando a um mínimo local e por coincidência a posição inicial da maioria das partículas da população tende a ser atraído para o mínimo local, logo a maioria da população para nesse ponto e o algoritmo termina antes de encontrar uma solução tão boa quando seria possível.\\
%% Fim do [Influencia na Solução] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.2 ::: Espaço de Soluções
%% 2.2.2.4
%\subsubsection{Implementação}
\indent Durante a implementação de um algoritmo para geração do espaço de soluções, foram percebidos diversos detalhes que influenciam fortemente na qualidade final do algoritmo. Nessa seção será analisado alguns desses pontos.\\
%\subsubsubsection{Inicialização}
\indent Um ponto importante percebido na implementação é como sera inicializado o \textit{array} onde será armazenado o espaço de soluções.\\
\indent O NumPy disponibiliza trés métodos de inicialização para um novo \textit{array} sem um valor de preenchimento, dos quais cada um demonstrou um problema diferente para a implementação. Dentre eles: 
\begin{itemize}
    \item \textit{numpy.zeros}: ao inicializar o \textit{array} com todos os valores preenchidos com o valor "$0$", devido ao processo de embaralhamento das operações, o algoritmo pode acabar gerando resultados errôneos. Por não existir uma máquina $M_0$ algumas operações não eram consideradas no resultado, e devido à falta de algumas operações, a solução em questão tinha um valor de \textit{fitness} menor, o que tendia a fazer essa solução errônea a melhor.

    \item \textit{numpy.ones}: ao inicializar o \textit{array} com todos os valores preenchidos com o valor "$1$", o algoritmo gerava soluções que tendiam a sobre carregar a máquina $M_1$ e assim os resultados finais tendiam a ter um valor de \textit{fitness} mais alto.

    \item \textit{numpy.empty}: esse método de inicialização diferentemente dos outros, não defini nenhum valor para os registros da matriz, somente aloca um bloco de memória (semelhante ao \textit{malloc} da linguagem C), o que o torna mais rápido, porém ele traz o revés de possivelmente ter valores errados, pois por simplesmente alocar um bloco de memória, o \textit{array} pode ser inicializado com valores estranhos devido a lixo de memória.
\end{itemize}

\noindent Devido aos problemas citados acima, acaba sendo necessário de qualquer maneira percorrer todo o \textit{array} para setar valores. \newline 
Então foi optado por utilizar um método de preenchimento de valores aleatório, 
gerados pela função \textit{numpy.random.choice} que gera um \textit{array} de valores aleatórios seguindo uma distribuição uniforme, 
conforme demonstrado no Gráfico da \hyperref[fig:distrib-uniforme]{Figura \ref{fig:distrib-uniforme}}.

\begin{figure}[ht]
    \centering
    \caption{Gráfico de distribuição de valores gerados pela função aleatória}
    \label{fig:distrib-uniforme}
    \includegraphics[width=\textwidth]{assets/hist_uniform.png}
\end{figure}

%
%% Inicialização do Array

Após as análises citadas acima foi feito uma modelagem e desenvolvido para esse trabalho o algoritmo de inicialização do espaço de soluções representado pelo 
\hyperref[alg:generate-solution-space]{Pseudocódigo \ref{alg:generate-solution-space}}.\\
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}
\caption{Pseudocódigo de geração do espaço de soluções}\label{alg:generate-solution-space}
\begin{algorithmic}
\State espaço soluções $\gets$ lista vazia
\State contador  $\gets$ 0
\While{ contador $\leq$ tamanho espaço de soluções}
  \State solução $\gets$ lista vazia
  \State embaralhar(operações)
  \State embaralhar(jobs)
  \State embaralhar(máquinas)
  \State solução[operações] $\gets$ remover ultimo elemento(operações)
  \State solução[jobs] $\gets$ remover ultimo elemento(jobs)
  \State solução[máquinas] $\gets$ remover ultimo elemento(máquinas)
  \State espaço soluções $\gets$ adicionar(solução)
\EndWhile
\end{algorithmic}
\end{algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fim do [Implementação] %%
%% Fim do [Espaço de Soluções] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.3
\subsection{Partícula}
%% Interlúdio %%
Por se tratar de um algoritmo populacional focado em partículas, por isso o nome \textit{Particle Swarm Optimization} que significa Otimização por Enxame de Partículas, a representação dessa entidade, assim como sua geração, controle e movimentação, se mostra um dos principais pilares do algoritmo. Devido a critérios de legibilidade e facilitação de futuros estudos nesse trabalho foi optado por criar uma estrutura de classe bem definida para essa representação e controle.
%% Fim do [Interlúdio] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.3 ::: Partícula
%% 2.2.3.1
%\subsubsection{Implementação}
Nessa classe são guardados os valores de: posição, velocidade e $pBest$, além de outros dados utilizados para facilitar o gerenciamento como: valor da solução da sua atual posição, assim como seu valor de \textit{fitness} e o tamanho do espaço de soluções.\\
\indent Para fazer uma melhor movimentação foi optado por não usar uma variável de direção, mas sim uma variável que guarda a última posição onde a partícula esteve.\\
Além da armazenagem dos valores da partícula, a classe da Partícula também implementa algumas funções como:
\begin{itemize}
    \item Função \textbf{\textit{fill\_with\_random\_values}} que gera uma posição inicial e uma velocidade aleatória para a partícula.

    \item Função \textbf{\textit{evaluate\_value}} que faz o cálculo do valor de \textit{fitness} da atual posição e o compara com a variável $pBest$ e caso seja melhora, atualiza o $pBest$.

    \item Função \textbf{\textit{update\_position}} que faz a movimentação da partícula.
\end{itemize}

Em implementações de código aberto como a já citada \textit{PySwarms}, também se utiliza uma representação de classe, porém sem nenhuma responsabilidade de cálculo de \textit{fitness}, atualização de posição ou de preenchimento de valores aleatórios na partícula.


%% Fim do [Representações] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.3 ::: Partícula
%\subsubsection{Movimentação}
A movimentação da partícula no espaço de soluções é o ponto mais importante dessa entidade. Pois, se não for feita da maneira certa pode fazer o algoritmo não desempenhar tão quanto o possível.


Como a implementação do espaço de soluções foi feita utilizando uma representação matricial, o mecanismo de movimentação mais intuitivo seria uma movimentação por soma de inteiros.


Aonde se tem uma direção e com base nessa direção se soma ou subtrai o valor de velocidade do eixo de movimento e assim se obtém uma nova posição, como mostrado no \hyperref[alg:int-sum]{Pseudocódigo \ref{alg:int-sum}}.
\begin{algorithm}
    \caption{Pseudocódigo de movimentação por soma de inteiros}\label{alg:int-sum}
\begin{algorithmic}
\If{direcao = CIMA}
  \State posicaoY = posicaoY + 1
\ElsIf{direcao = ESQUERDA}
  \State posicaoX = posicaoX - 1
\ElsIf{direcao = DIREITA}
  \State posicaoX = posicaoX + 1
\ElsIf{direcao = BAIXO}
  \State posicaoY = posicaoY - 1
\ElsIf{direcao = SUPERIOR ESQUERDA}
  \State posicaoX = posicaoX - 1
  \State posicaoY = posicaoY + 1
\ElsIf{direcao = SUPERIOR DIREITA}
  \State posicaoX = posicaoX + 1
  \State posicaoY = posicaoY + 1
\ElsIf{direcao = INFERIOR ESQUERDA}
  \State posicaoX = posicaoX - 1
  \State posicaoY = posicaoY - 1
\ElsIf{direcao = INFERIOR DIREITA}
  \State posicaoX = posicaoX + 1
  \State posicaoY = posicaoY - 1
\EndIf    
\end{algorithmic}
\end{algorithm}


Ou seja, tendo uma posição $[15, 7]$ sendo $15$ o valor de $x$ e $7$ o valor de $y$,
uma velocidade $2$ e a direção do movimento ser \textit{CIMA}, a nova posição é obtida incrementado a velocidade ao valor de $y$ da posição, ou seja $[15, 7+2]$, então a nova posição seria $[15, 9]$.


Essa abordagem funciona bem para uma movimentação simples em espaços 2D. Sendo inclusive muito utilizada no desenvolvimento de jogos com mapas baseados em ladrilhos (\textit{Tile-based} / \textit{Grid-based}).


Porém, no caso do algoritmo PSO é necessário considerar a inércia e uma média entre o $pBest$ e o $gBest$ obtendo assim uma nova posição, o que gera muitas vezes uma movimentação em ângulos mais específicos o que torna a abordagem de soma de inteiros muito complexa e limitada para esse cenário.
Então nesse trabalho foi desenvolvido um método de movimentação baseado em cálculos vetoriais que elimina esses problemas de movimentação além de facilitar a implementação de novos pontos de comparação (além do $pBest$ e $gBest$) para o cálculo da nova posição.


Essa abordagem de movimentação é baseado no conceito de \textit{Produto Escalar} definido pela Álgebra Linear, e representa o produto interno padrão do espaço euclidiano sendo definido como uma operação binaria entre dois vetores.
Em um cenário aonde a posição da partícula é $position=[12,8]$ e $pBest=[10, 15]$, $gBest=[16,20]$ e $velocidade=[2,4]$.
Para encontrar a nova posição de uma partícula são utilizados:
\begin{itemize}
\item $\vec p$ Que representa o vetor entre a partícula e o $pBest$ 
(\hyperref[fig:vetor-p]{Figura \ref{fig:vetor-p}}).
\item $\vec g$ Que representa o vetor entre a partícula e o $gBest$ 
(\hyperref[fig:vetor-g]{Figura \ref{fig:vetor-g}}).
\item $\vec r$ Que representa o vetor final de movimento
(\hyperref[fig:vetor-r]{Figura \ref{fig:vetor-r}}).
\end{itemize}

\begin{figure}[!htb]
\begin{minipage}{\textwidth}

% 1º linha
\begin{minipage}{0.48\textwidth}
\centering
\caption{Vetor $\vec v$ de movimento}
\label{fig:vetor-v}
\includegraphics[width=.9\linewidth]{assets/vec1.png}
%\small{Incluir vetor v aqui}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\centering
\caption{Vetor $\vec p$ de o $pBest$}
\label{fig:vetor-p}
\includegraphics[width=.9\linewidth]{assets/vec2.png}
%\small{Incluir vetor p aqui}
\end{minipage}

% 2º linha
\begin{minipage}{0.48\textwidth}
\centering
\caption{Vetor $\vec g$ de $gBest$}
\label{fig:vetor-g}
\includegraphics[width=.9\linewidth]{assets/vec3.png}
%\small{Incluir vetor g aqui}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\centering
\caption{Vetor $\vec r$ de movimento final}
\label{fig:vetor-r}
\includegraphics[width=.9\linewidth]{assets/vec4.png}
%\small{Incluir vetor w aqui}
\end{minipage}

\end{minipage}
\end{figure}

A nova posição da partícula é dada pela 
\hyperref[eq:movimentacao-vec]{Equação \ref{eq:movimentacao-vec}} 
E a partir dela temos o vetor $\vec r$ resultante, então a nova posição da partícula é $[12,10]$.
.
%
\begin{equation} 
    \label{eq:movimentacao-vec}
    \vec r = ((\vec g + \vec p) / 2) + \vec v
\end{equation}

Na implementação em Python para realizar os cálculos vetoriais foi utilizado a biblioteca \textit{Numpy}.
Para isso primeiro é calculado um vetor médio entre $pBest$ e $gBest$, e o vetor $\vec w$ representando a inércia.
Então a posição atual da partícula é deduzido do valor médio entre $pBest$ e $gBest$, isso é feito para que calcular o vetor como se a posição atual da partícula fosse o ponto $[0,0]$ do mapa.


Então somado com o vetor de inércia divido por um valor de significância para a inércia (Definido pelos parâmetros de configuração do algoritmo).
No \hyperref[alg:mov-part]{Pseudocódigo \ref{alg:mov-part}} é possível ver a representação dessa função de cálculo
\begin{algorithm}
    \caption{Pseudocódigo de movimentação de partícula}\label{alg:mov-part}
\begin{algorithmic}
\State vetor de inércia $\gets$ (posição inicial $*$ velocidade)
\State melhor media $\gets$ ($pBest$ + $gBest$) / 2
\State vetor final $\gets$ (melhor media + posição inicial) / 2
\end{algorithmic}
\end{algorithm}
%% Fim do [Movimentação Vetorial] %%
%% Fim do [Movimentação] %%
%% Fim do [Partícula] %%
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
\subsection{População}
Pelo algoritmo PSO ser um algoritmo baseado em inteligência populacional, ele é muito influenciado pela geração da população inicial, mesmo nos algoritmos com variações aonde existem mutações e consequentemente evolução dos indivíduos da população, as características como inercia, velocidade, direção e posição desses indivíduos da população inicial são de grande importância.\\
%
%
\indent Os parâmetros como o tamanho da população são definidos nas configurações de hiper parâmetros do algoritmo.
%
Já as funções utilizadas na geração dos indivíduos iniciais utilizam alguns valores aleatórios que seguem um padrão de distribuição uniforme. Os atributos que utilizam valores aleatórios são:
\begin{itemize}
    \item A velocidade, dada por um valor aleatório entre $0.1$ e $0.2$.
    \item A posição inicial da partícula, dada por dois números aleatórios entre $1$ e o limite do espaço de soluções $- 1$.
    \item A última posição da partícula, obtida através de um número inteiro aleatório entre $1$ e $-1$ diferente de zero.
\end{itemize}
%
%
\indent Assim, como valores iniciais seguindo uma distribuição uniforme é observado uma geração de população inicial bem distribuída, dificultando o acontecimento de convergência prematura.\\
%
%
Sendo assim, todas as variações do algoritmo PSO implementadas nesse trabalho utilizam a mesma função geradora de população inicial.
%%% 
\noindent Garantindo assim um ponto de comparação mais justo entre os algoritmos.
%% 2 ::: Desenvolvimento
%% 2.2 ::: Arquitetura
%% 2.2.5
\subsection{Algoritmos}
%%
A execução dos algoritmos é chamada pela classe principal de modelagem do problema, responsável por realizar a execução e controle dos dados de análise.\\
%
Na classe do PSO estão as funções da condição de parada, movimento e \textit{evaluete} do \textit{fitness} da partícula\\
%
%
Como critério de parada para o algoritmo foi utilizado o fator de atualização do $gBest$. Quando a última atualização do $gBest$ for a mais rodadas do que metade da quantidade de partículas, o algoritmo termina e o resultado é o $gBest$ atual.\\
%%
\indent O que diferencia as abordagens analisadas nesse trabalho são as heurísticas de movimentação das partículas.\\
A movimentação básica de uma partícula do PSO é definido pela
\hyperref[eq:movimentacao-particula]{Equação \ref{eq:movimentacao-particula}}
.
%
\begin{equation} 
    \label{eq:movimentacao-particula}
    \vec v_1(t+1)= \vec v_i(t) + a_1 r_1 (pBest - \vec x_i(t)) + a_2 r_2 (gBest - \vec x_i(t))
\end{equation}
%
Como foi observado nos testes a variável aleatória é importam de para que as partículas não entrem em um estado de equilíbrio e parem de se movimentar. Com a introdução de elementos aleatórios a movimentação se torna mais caótica e evita o fim prematuro do algoritmo.

Esse impacto na movimentação inspirou uma abordagem que considera o nível de atualizações de $gBest$ e assim adiciona mais um fator aleatório no cálculo. como é representado no 
\hyperref[alg:mov-dinamic]{Pseudocódigo \ref{alg:mov-dinamic}}.
\begin{algorithm}
    \caption{Pseudocódigo de movimentação com componente dinâmico}\label{alg:mov-dinamic}
\begin{algorithmic}

\State vetor de inércia $\gets$ (posição inicial * velocidade)
\State melhor media $\gets$ (($pBest$ + $gBest$) / 2)
\State vetor final $\gets$ ((melhor media + posição inicial) / 2)

\If{trocas de $gBest$ é menor que (tamanho da populacao / $10$)}
    \State vetor final $\gets$ vetor de movimento $+$ $0.1$ $*$ (inercia$*$random($0.1$, $0.9$))
\Else
    \State vetor final $\gets$ vetor de movimento $+$ $0.1$ $*$ random($0.1$, $0.9$) 
\EndIf    
\end{algorithmic}
\end{algorithm}

%% Fim do [Algoritmos] %%
%% Fim do [Arquitetura] %%
%% 2 ::: Desenvolvimento
%% 2.3
\section{Execuções}
Foram utilizados como parâmetros de configuração:
\begin{itemize}
    \item \code{population\_size} Quantidade de partículas
    \item \code{coeficente\_populacional}: coeficiente entre a quantidade de partículas e o tamanho do espaço de soluções
\end{itemize}
%
O tamanho do espaço de soluções é calculado pela raiz quadrada do arrendamento do tamanho da população elevado ao coeficiente populacional, representado pela equação 
\hyperref[eq:space-size]{Equação \ref{eq:space-size}}, 
sendo $p$ o tamanho da população e $c$ o coeficiente populacional.
Essa equação é necessária, pois para gerar um espaço de soluções $n \times n$ pois para isso o número precisa ser uma raiz quadrada perfeita.
%
\begin{equation} 
    \label{eq:space-size}
    space\_size = \lfloor \sqrt{\lfloor p^c \rceil} \rceil
\end{equation}
%

Por exemplo, no caso de uma população de tamanho $30$ e um coeficiente populacional $2.3$, temos $\lfloor 30^{2.3} \rceil = 2497$ e então $\lfloor \sqrt{2497} \rceil = 50$.\\
Para essa analise foram usados os valores de \code{population\_size = 30} e o 3 valores diferentes de coeficiente populacional que são:
\begin{itemize}
    \item \code{coeficiente\_populacional = $2.3$}: Gera um mapa de $50 \times 50$
    \item \code{coeficiente\_populacional = $2.5$}: Gera um mapa de $70 \times 70$
    \item \code{coeficiente\_populacional = $2.645$}: Gera um mapa de $90 \times 90$
\end{itemize}

Foram gerados 20 espaços de solução diferentes para cada um dos 3 coeficientes e cada um dos 4 cenários de problema diferentes, totalizando assim $240$ espaços de soluções diferentes.

Pela natureza variável do ambiente em nuvem e por se tratar de um algoritmo que utiliza fatores aleatórios, a execução de cada uma das 2 abordagens foi repetida 20 vezes para assim obter uma média mais precisa das soluções de cada algoritmo.


Para assegurar uma análise posterior mais detalhada, os dados gerados pelos algoritmos foram salvos em aquivo binário.
Os dados salvos são a população inicial, o espaço de soluções, o número de rodadas, o histórico da variável $gBest$, o histórico da posição das partículas e as Soluções encontradas.
%% 2 ::: Desenvolvimento
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Resultados}
Para avaliar as execuções dos algoritmos foram estabelecidos os seguintes critérios de análise:
A partir das médias estatísticas das execuções, são utilizados como critérios de avaliação do algoritmo:
\begin{itemize}
\item Makespan final das soluções.
\end{itemize}

\noindent E são parâmetros de análise:
\begin{itemize}
\item Taxa de mudança da variável $gBest$ ao longo da execução.
\item Quantidade de rodadas necessárias para atingir o critério de parada.
\item Taxa de mudanças de $pBest$ por rodada.
\item Histórico de movimentação das partículas.
\end{itemize}

Nas Figuras \ref{fig:plobA-freq-mk}, \ref{fig:plobB-freq-mk}, \ref{fig:plobC-freq-mk} e \ref{fig:plobD-freq-mk} 
estão representadas as frequências de \textit{Makespan} das execuções, os dados na cor azul representam os resultados obtidos com a implementação padrão do algoritmo PSO, e na cor laranja estão representados os resultados alcançados com a implementação do componente dinâmico de inércia.

Foram utilizados nos testes \textit{datasets} com tamanhos variados, sendo eles, 
problema A $4 \times 5$,
problema B $10 \times 7$,
problema C $10 \times 10$,
problema D $15 \times 10$.
Todos esses \textit{datasets} foram retirados dos \textit{benchmarks} de \cite{Kacem2002}.
%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problema A}
O problema A tem um tamanho $4 \times 5$, ou seja, com 4 \textit{jobs} e 5 máquinas, sendo esse o menor dos \textit{datasets} analisados.
Na \hyperref[fig:plobA-freq-mk]{Figura \ref{fig:plobA-freq-mk}} é possível perceber que o componente dinâmico obteve uma pequena tendência a obter um valor menor de \textit{makespan}, ou seja, atingir um melhor resultado, principalmente nas execuções com um espaço de soluções maior, como na \hyperref[plobA-freq-mk:c]{Figura \ref{plobA-freq-mk:c}}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htb]
    \caption{Problema A — Gráfico de Frequência de Makespan}
    \label{fig:plobA-freq-mk}
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobA-freq-mk:a}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_1_0.pgf}}
        }
    \end{minipage}%
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobA-freq-mk:b}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_1_1.pgf}}
        }
    \end{minipage}\par\medskip
      \centering
      \subfloat[]{
        \label{plobA-freq-mk:c}
        \resizebox{.5\linewidth}{!}{\input{assets/problems/problem_legended_1_2.pgf}}
      }
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Na
\hyperref[tab:tableA-freq-mk]{Tabela \ref{tab:tableA-freq-mk}}
é representado as estatísticas entre os valores de \textit{makespan} obtidos pelas execuções de cada abordagem.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!htb]
    \centering
    \caption{Tabela de dados estatísticos da execução do problema A}
    \label{tab:tableA-freq-mk}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|ll|ll|ll|}
    \hline
    \multicolumn{1}{|c|}{Problema A} & \multicolumn{2}{c|}{$50 \times 50$} & \multicolumn{2}{c|}{$70 \times 70$} & \multicolumn{2}{c|}{$90 \times 90$} \\ \cline{2-7} 
        \multicolumn{1}{|c|}{$4 \times 5$} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} \\ \hline
    Média & \multicolumn{1}{l|}{11.253} & 11.254 & \multicolumn{1}{l|}{11.196} & 11.093 & \multicolumn{1}{l|}{11.121} & 11.036 \\ \hline
    Mediana & \multicolumn{1}{l|}{11.0} & 11.0 & \multicolumn{1}{l|}{11.0} & 11.0 & \multicolumn{1}{l|}{11.0} & 11.0 \\ \hline
    Desvio Padrão & \multicolumn{1}{l|}{0.443} & 0.443 & \multicolumn{1}{l|}{0.397} & 0.29 & \multicolumn{1}{l|}{0.348} & 0.186 \\ \hline
    Variância & \multicolumn{1}{l|}{0.196} & 0.196 & \multicolumn{1}{l|}{0.158} & 0.084 & \multicolumn{1}{l|}{0.121} & 0.034 \\ \hline
    Mínimo & \multicolumn{1}{l|}{11} & 11 & \multicolumn{1}{l|}{11} & 11 & \multicolumn{1}{l|}{11} & 11 \\ \hline
    Máximo & \multicolumn{1}{l|}{13} & 13 & \multicolumn{1}{l|}{12} & 12 & \multicolumn{1}{l|}{13} & 12 \\ \hline
    \end{tabular}%
    }
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


É possível ver que a abordagem dinâmica 
apresentou em 
um \textit{makespan} em média $1,16\%$ menor e com um
desvio padrão $40\%$ menor e uma
variância $62,5\%$ menor
em relação à abordagem padrão.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problema B}
O problema B tem um tamanho $10 \times 7$, ou seja, com 10 \textit{jobs} e 7 máquinas, 
sendo esse o segundo menor dos \textit{datasets} analisados.
Na \hyperref[fig:plobB-freq-mk]{Figura \ref{fig:plobB-freq-mk}} 
é possível perceber que o componente dinâmico obteve uma 
tendência de atingir um valor menor de \textit{makespan}, 
uma tendência maior do que a observada 
na \hyperref[fig:plobA-freq-mk]{Figura \ref{fig:plobA-freq-mk}}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htb]
    \caption{Problema B — Gráfico de Frequência de Makespan}
    \label{fig:plobB-freq-mk}
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobB-freq-mk:a}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_2_0.pgf}}
        }
    \end{minipage}%
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobB-freq-mk:b}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_2_1.pgf}}
        }
    \end{minipage}\par\medskip
      \centering
      \subfloat[]{
        \label{plobB-freq-mk:c}
        \resizebox{.5\linewidth}{!}{\input{assets/problems/problem_legended_2_2.pgf}}
      }
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Na
\hyperref[tab:tableA-freq-mk]{Tabela \ref{tab:tableA-freq-mk}}
é representado as estatísticas entre os valores de \textit{makespan} obtidos pelas execuções de cada abordagem.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!htb]
    \centering
    \caption{Tabela de dados estatísticos da execução do problema B}
    \label{tab:tableB-freq-mk}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|ll|ll|ll|}
        \hline
        \multicolumn{1}{|c|}{Problema B} & \multicolumn{2}{c|}{$50 \times 50$} & \multicolumn{2}{c|}{$70 \times 70$} & \multicolumn{2}{c|}{$90 \times 90$} \\ \cline{2-7} 
        \multicolumn{1}{|c|}{$10 \times 7$} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} \\ \hline
        Média & \multicolumn{1}{l|}{18.129} & 17.521 & \multicolumn{1}{l|}{18.05} & 17.404 & \multicolumn{1}{l|}{18.286} & 17.307 \\ \hline
        Mediana & \multicolumn{1}{l|}{18.0} & 17.5 & \multicolumn{1}{l|}{18.0} & 18.0 & \multicolumn{1}{l|}{18.0} & 17.0 \\ \hline
        Desvio Padrão & \multicolumn{1}{l|}{1.535} & 1.394 & \multicolumn{1}{l|}{1.585} & 1.434 & \multicolumn{1}{l|}{1.275} & 1.416 \\ \hline
        Variância & \multicolumn{1}{l|}{2.355} & 1.942 & \multicolumn{1}{l|}{2.512} & 2.055 & \multicolumn{1}{l|}{1.626} & 2.006 \\ \hline
        Mínimo & \multicolumn{1}{l|}{13} & 13 & \multicolumn{1}{l|}{13} & 13 & \multicolumn{1}{l|}{15} & 13 \\ \hline
        Máximo & \multicolumn{1}{l|}{21} & 21 & \multicolumn{1}{l|}{22} & 22 & \multicolumn{1}{l|}{22} & 21 \\ \hline
    \end{tabular}%
    }
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
É possível ver que a abordagem dinâmica 
apresentou em 
um \textit{makespan} em média $4,07\%$ menor e com um
desvio padrão $4,08\%$ menor e uma
variância $7,83\%$ menor
em relação à abordagem padrão.


A porcentagem de melhora em relação ao PSO padrão se mostrou melhor na média de \textit{makespan} obtidos, porém foi menor nos valores de variância e de desvio padrão, isso parece estar relacionado ao tamanho do \textit{dataset} anterior ser pequeno, o que gera menos resultados possíveis e não existe muito espaço de melhora.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problema C}
O problema C tem um tamanho $10 \times 10$, ou seja, com 10 \textit{jobs} e 10 máquinas, 
sendo esse o segundo maior dos \textit{datasets} analisados.
Na \hyperref[fig:plobC-freq-mk]{Figura \ref{fig:plobC-freq-mk}} 
%é possível perceber que o componente dinâmico obteve uma 
%tendência de atingir um valor menor de \textit{makespan}, 
%uma tendência melhor do que a observada 
%na \hyperref[fig:plobA-freq-mk]{Figura \ref{fig:plobA-freq-mk}}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htb]
    \caption{Problema C — Gráfico de Frequência de Makespan}
    \label{fig:plobC-freq-mk}
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobC-freq-mk:a}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_3_0.pgf}}
        }
    \end{minipage}%
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobC-freq-mk:b}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_3_1.pgf}}
        }
    \end{minipage}\par\medskip
      \centering
      \subfloat[]{
        \label{plobC-freq-mk:c}
        \resizebox{.5\linewidth}{!}{\input{assets/problems/problem_legended_3_2.pgf}}
      }
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Na
\hyperref[tab:tableC-freq-mk]{Tabela \ref{tab:tableC-freq-mk}}
é representado as estatísticas entre os valores de \textit{makespan} obtidos pelas execuções de cada abordagem.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!htb]
    \centering
    \caption{Tabela de dados estatísticos da execução do problema C}
    \label{tab:tableC-freq-mk}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|ll|ll|ll|}
        \hline
        \multicolumn{1}{|c|}{Problema C} & \multicolumn{2}{c|}{$50 \times 50$} & \multicolumn{2}{c|}{$70 \times 70$} & \multicolumn{2}{c|}{$90 \times 90$} \\ \cline{2-7} 
        \multicolumn{1}{|c|}{$10 \times 10$} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} \\ \hline
        Média & \multicolumn{1}{l|}{12.368} & 11.514 & \multicolumn{1}{l|}{11.946} & 11.207 & \multicolumn{1}{l|}{12.254} & 11.564 \\ \hline
        Mediana & \multicolumn{1}{l|}{12.0} & 11.0 & \multicolumn{1}{l|}{12.0} & 11.0 & \multicolumn{1}{l|}{12.0} & 12.0 \\ \hline
        Desvio Padrão & \multicolumn{1}{l|}{1.853} & 1.615 & \multicolumn{1}{l|}{1.807} & 1.658 & \multicolumn{1}{l|}{1.818} & 1.631 \\ \hline
        Variância & \multicolumn{1}{l|}{3.433} & 2.607 & \multicolumn{1}{l|}{3.265} & 2.75 & \multicolumn{1}{l|}{3.304} & 2.66 \\ \hline
        Mínimo & \multicolumn{1}{l|}{8} & 9 & \multicolumn{1}{l|}{8} & 8 & \multicolumn{1}{l|}{8} & 8 \\ \hline
        Máximo & \multicolumn{1}{l|}{16} & 17 & \multicolumn{1}{l|}{16} & 16 & \multicolumn{1}{l|}{16} & 16 \\ \hline
    \end{tabular}%
    }
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
É possível ver que a abordagem dinâmica 
apresentou em 
um \textit{makespan} em média $6,23\%$ menor e com um
desvio padrão $10,38\%$ menor e uma
variância $19,94\%$ menor
em relação à abordagem padrão.
Essa porcentagem monstra que a tendência de melhora é reforçada em \textit{datasets} maiores.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Problema D}
O problema D tem um tamanho $15 \times 10$, ou seja, com 10 \textit{jobs} e 10 máquinas, 
sendo esse o maior dos \textit{datasets} analisados.
Na \hyperref[fig:plobD-freq-mk]{Figura \ref{fig:plobD-freq-mk}} 
%é possível perceber que o componente dinâmico obteve uma 
%tendência de atingir um valor menor de \textit{makespan}, 
%uma tendência melhor do que a observada 
%na \hyperref[fig:plobA-freq-mk]{Figura \ref{fig:plobA-freq-mk}}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[!htb]
    \caption{Problema D — Gráfico de Frequência de Makespan}
    \label{fig:plobD-freq-mk}
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobD-freq-mk:a}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_4_0.pgf}}
        }
    \end{minipage}%
    \begin{minipage}{.5\linewidth}
        \centering
        \subfloat[]{
            \label{plobD-freq-mk:b}
            \resizebox{\linewidth}{!}{\input{assets/problems/problem_legended_4_1.pgf}}
        }
    \end{minipage}\par\medskip
      \centering
      \subfloat[]{
        \label{plobD-freq-mk:c}
        \resizebox{.5\linewidth}{!}{\input{assets/problems/problem_legended_4_2.pgf}}
      }
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Na
\hyperref[tab:tableD-freq-mk]{Tabela \ref{tab:tableD-freq-mk}}
é representado as estatísticas entre os valores de \textit{makespan} obtidos pelas execuções de cada abordagem.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[!htb]
    \centering
    \caption{Tabela de dados estatísticos da execução do problema D}
    \label{tab:tableD-freq-mk}
    \resizebox{\textwidth}{!}{%
    \begin{tabular}{|l|ll|ll|ll|}
        \hline
        \multicolumn{1}{|c|}{Problema D} & \multicolumn{2}{c|}{$50 \times 50$} & \multicolumn{2}{c|}{$70 \times 70$} & \multicolumn{2}{c|}{$90 \times 90$} \\ \cline{2-7} 
        \multicolumn{1}{|c|}{$15 \times 10$} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} & \multicolumn{1}{l|}{\textbf{PSO Base}} & \textbf{Dinâmico} \\ \hline
        Média & \multicolumn{1}{l|}{23.896} & 22.621 & \multicolumn{1}{l|}{23.129} & 22.107 & \multicolumn{1}{l|}{22.536} & 21.954 \\ \hline
        Mediana & \multicolumn{1}{l|}{24.0} & 23.0 & \multicolumn{1}{l|}{23.0} & 22.0 & \multicolumn{1}{l|}{22.0} & 22.0 \\ \hline
        Desvio Padrão & \multicolumn{1}{l|}{1.623} & 1.561 & \multicolumn{1}{l|}{1.666} & 1.418 & \multicolumn{1}{l|}{1.658} & 1.533 \\ \hline
        Variância & \multicolumn{1}{l|}{2.636} & 2.435 & \multicolumn{1}{l|}{2.776} & 2.01 & \multicolumn{1}{l|}{2.749} & 2.351 \\ \hline
        Mínimo & \multicolumn{1}{l|}{19} & 19 & \multicolumn{1}{l|}{19} & 19 & \multicolumn{1}{l|}{19} & 17 \\ \hline
        Máximo & \multicolumn{1}{l|}{28} & 26 & \multicolumn{1}{l|}{28} & 27 & \multicolumn{1}{l|}{28} & 26 \\ \hline
    \end{tabular}%
    }
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
É possível ver que a abordagem dinâmica 
apresentou em 
um \textit{makespan} em média $4,14\%$ menor e com um
desvio padrão $12,06\%$ menor e uma
variância $22,77\%$ menor
em relação à abordagem padrão.


Nesse caso vemos uma redução na melhora de comparado aos testes anteriores, porém continua a aumentar a redução do desvio padrão e da variância. Porém, é possível ver que na \hyperref[plobD-freq-mk:c]{Figura \ref{plobD-freq-mk:c}} a abordagem dinâmica entrou soluções com um valor de \textit{makespan} de $17$ e $18$, valores que não foram encontrados pela abordagem padrão.


Por fim, podemos concluir que com as reduções de 
\textit{makespan} de $1.16\%$, $4.07\%$, $6.23\%$, $4.14\%$, de 
desvios padrões de $40\%$, $4.08\%$, $10.38\%$, $12.06\%$, e 
de variâncias de $62.5\%$, $7.83\%$, $19.94\%$, $44.77\%$, vemos que na média houve uma redução de $3,90\%$ no \textit{makespan}, de $16,63\%$ no desvio padrão e de $33,76\%$ na variância. Essa abordagem não traz uma redução significativa no tempo final de \textit{makespan}, porém traz um menor desvio padrão e menor variância, fazendo assim com que o algoritmo PSO tenha uma maior confiabilidade de bons resultados.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Fim do [Resultados] %%
