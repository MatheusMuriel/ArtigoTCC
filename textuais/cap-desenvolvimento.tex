%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 2 ::: Desenvolvimento
\chapter{Desenvolvimento}
    %% Interlúdio do [Desenvolvimento] %%
        ...
    %% Fim do Interlúdio do [Desenvolvimento] %%


%% 2 ::: Desenvolvimento
%% 2.1
\section{Metodologia de Pesquisa}
    %% Interlúdio do [Metodologia de Pesquisa] %%
        Para os testes deste trabalho estão sendo usados os mesmo problemas utilizados por \cite{Kacem2002}, e já são largamente usados na literatura. Sendo representados por $[j, o, m]$ em que $j$ é a quantidade de \textit{jobs}, $o$ é a quantidade de operações e $m$ a quantidade de máquinas. Para observar o comportamento do algoritmo em diversos cenários foram escolhidos problemas de tamanhos variados, sendo eles $[4, 12, 5]$, $[10, 29, 7]$, $[10, 30, 10]$ e $[15, 56, 10]$. Os problemas de teste podem ser encontrados nos apêndices do trabalho.\newline

        Os algoritmos foram executados no ambiente de nuvem Google Colab Code sendo executado no motor \textit{Python 3 Google Compute Engine Backend}. Para a execução foram utilizados somente processadores comuns (CPU) e 12 Gb de memória RAM.
    %% Fim do Interlúdio do [Metodologia de Pesquisa] %%

    %% 2 ::: Desenvolvimento
    %% 2.1 ::: Metodologia de Pesquisa
    %% 2.1.1
    \subsection{Objetivos}
        ... Bla bla bla ...Analise visa descobrir e analisar como as alterações afetam a qualidade do algoritmo... Bla bla bla...
    %% Fim do [Objetivos] %%
 %
%% Fim do [Metodologia de Pesquisa] %%


%% 2 ::: Desenvolvimento
%% 2.2
\section{Arquitetura}
    %% Interlúdio do [Arquitetura] %%
        A arquitetura de um projeto de é um fator que impacta diretamente no seu desempenho, porém como o objetivo desse trabalho é entender como o algoritmo PSO se comporta diante das alterações propostas, foi necessário o desenvolvimento de uma arquitetura que represente o problema de maneira mais abstrata.
    %% Fim do Interlúdio do [Arquitetura] %%

    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.1
    \subsection{Design do Projeto}
        Por esse trabalho ser desenvolvimento dentro de um grupo de estudos, foi optado por usar uma estrutura de projeto mais didática e de fácil entendimento, de maneira que possa ser facilmente reutilizada por futuros estudantes. Porém, essa escolha acarreta uma certa perda de desempenho, porém, como se trata de um trabalho que visa explorar como cada tipo de alteração impacta o algoritmo, essa perca de desempenho não se torna um defeito.\newline
        
        O projeto foi desenvolvido na linguagem de programação Python versão 3.9.7 e utiliza além das bibliotecas básicas da linguagem, as bibliotecas:
        \begin{itemize}
            \item NumPy (versão 1.21.3)
            \item MatPlotlib (versão 3.4.3)
        \end{itemize}

        \hfill\newline
        \noindent O MatPlotlib foi utilizado para a geração de: 
        \begin{itemize}
            \item Gráficos de Dispersão (\textit{Scatter Plot}) para representar a posição das partículas da população.
            \item Gráficos de Superfície (\textit{Surface Plot}) para representar o espaço de soluções.
            \item Gráficos de Barra Horizontal (\textit{Horizontal Bar Plot}) para representar um diagrama de Gantt com a solução do agendamento.
        \end{itemize}
        
        \hfill\newline
        \noindent O NumPy foi utilizado para: 
        \begin{itemize}
            \item Grandes arranjos multi dimensionais de dados. 
            \item Funções randômicas de escolha.
            \item Ordenação de dados.
            \item Operações de cálculo como raiz quadrada e potenciação.
            \item Funções de escolha de valores máximos e mínimos.
            \item Modelagem, união e remodelagem de matrizes.
            \item Representações e calculo de vetores de movimentação.
        \end{itemize}
        
        \hfill\newline
        Para trazer mais clareza ao código foi optado por criar algumas classes para a representação de entidades e abstração de lógicas. Dentre elas estão:\newline
        
        Classe de Partícula, que faz a representação de uma entidade de partícula e armazena sua posição, velocidade e direção. Faz a inicialização da partícula com valores aleatórios de posição, velocidade e direção. E estabelece métodos para calcular o movimento da partícula e o valor da qualidade de sua nova posição.\newline
        
        Classe de \textit{encoding}, responsável por ler e interpretar os arquivos de instância de um problema, criar uma representação para de solução, e então gerar o espaço de soluções com soluções geradas aleatoriamente.\newline
         
        Classe de \textit{decoding}, responsável por decodificar uma solução no padrão de representação estabelecido pela classe de \textit{encoding} e calcular o \textit{fitness} dessa solução. Essa classe também estabelece o método que gera o gráfico de Gantt para representar visualmente a solução.\newline
        

        Como o PSO é um algoritmo estocástico, ou seja, seu resultado é fruto de eventos não previsíveis, como a geração aleatória de soluções, foi decidido que para obter uma média real dos desempenhos de cada algoritmo, em cada uma das 30 execuções será gerado um novo espaço de soluções e uma população inicial diferente.\newline
        E em cada uma dessas execuções será passado para cada um dos algoritmos uma \textit{Deepcopy} do espaço de soluções e da população inicial, para que os diferentes algoritmos trabalhem com base nos mesmos dados iniciais, para assim tem uma análise mais justa.\newline

        Para que a análise dos dados possa ser feita mais detalhadamente, foram implementados alguns pontos de salvamento de dados, para salvar em arquivo texto as representações da população e do espaço de soluções gerados aleatoriamente, assim como a quantidade de rodadas feitas, o histórico da variavel $gBest$, o número de mudanças de $pBest$, o histórico de posição das partículas e as soluções finais encontradas.
     %
    %% Fim do [Design do Projeto] %%
    

    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.2
    \subsection{Espaço de Soluções}
        %% Interludio %%
            O espaço de soluções (também chamado espaço de busca) é um conceito que define um espaço imaginário aonde cada ponto desse espaço é uma possível solução para o problema em questão. 
            Um espaço de soluções pode ser representado de diversas maneiras, como listas e grafos, mas em problemas de optimização normalmente se usa uma representação na forma de uma matriz.\newline
        %% Fim do [Interludio] %%
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.1
        \subsubsection{Representações}
            Nessa representação em forma de matriz cada localização $[i, j]$ tem uma solução valida para o problema, e o algoritmo em questão tem a tarefa de encontrar qual dessas posições tem a melhor solução, ou uma solução boa o suficiente. Na 
            \hyperref[fig:solution-space]{Figura \ref{fig:solution-space}} 
            é mostrado uma representação conceitual de um espaço de soluções em forma de matriz.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a imagem do exemplo de espaço de solução aqui}
                \caption{Figura X}
                \label{fig:solution-space}
            \end{figure}

            Algumas das implementações encontradas em bibliotecas de algoritmos populacionais de código aberto como \textit{PySwarms} utilizam internamente um sistema de representação de espaço de soluções de uma única dimensão, ou seja, uma lista simples, e utiliza uma função para transformar uma posição $[x,y]$ em um índice da lista. Essa implementação provavelmente foi escolhida por ser na maioria dos casos, mais rápida em comparação a uma abordagem de duas dimensões. \newline
        %% Fim do [Representações] %%


        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.2
        \subsubsection{Gráficos de análise}
            Como esse trabalho tem como foco uma exploração e implementação mais didática foi optado a utilização de uma representação em forma de uma matriz com duas dimensões, utilizando a biblioteca \textit{NumPy}. Essa abordagem em matriz de duas dimensões também facilita a geração de gráficos para representação visual, como, por exemplo, passar a matriz de soluções pela função de avaliação e assim obter um valor de \textit{fitness} para cada ponto do espaço de soluções, como é possível ver na 
            \hyperref[fig:surfaceplot]{Figura \ref{fig:surfaceplot}} 
            na qual os valores mais acima e mais escuros tem um valor de \textit{fitness} mais alto (ou seja, pior), e os valores mais abaixo e mais claros tem um \textit{fitness} mais baixo (ou seja, melhor).\newline

            \begin{figure}[h]
                \centering
                \small{Incluir a grafico surface aqui}
                \caption{Gráfico surface simples}
                \label{fig:surfaceplot}
            \end{figure}

            Esses gráficos se mostraram extremamente uteis ao decorrer do desenvolvimento deste trabalho, servindo para validar detectar erros na função de inicialização do espaço de soluções.\newline
        %% Fim do [Graficos de Analise] %%


        %% Influencia na solução
        \subsubsection{Influencia na Solução}
            A geração do espaço de soluções é muito importante no caso de um algoritmo como o PSO 
            que funciona com base na movimentação de acordo com as médias de melhores posições, 
            devido a isso, o PSO tente a ter problemas com convergencia prematura em minimos locais.\newline
            
            Os minimos locais são fenomenos aonde dentro de uma parte do espaço de soluções existe um ponto que é melhor do que a media dos pontos a sua volta, porém não é o melhor entre o todo o espaço de soluções, como é possivel ver na \hyperref[fig:ex-minimolocal]{Figura \ref{fig:ex-minimolocal}}.\newline
            \begin{figure}[h]
                \centering
                \small{Incluir um grafico de minimo local aqui}
                \caption{Exemplo de um minimo local}
                \label{fig:ex-minimolocal}
            \end{figure}
            

            Já que esse ponto se destaca muito entre seus vizinhos o algoritmo pode ficar preso nesta região, pois a media local sempre tende para o ponto no qual está o minimo local.\newline

            Como o PSO se baseia na media local e global, se houver mais de um minimo local e quantidades equivalentes de particulas da população forem distribuidas para esses pontos, as particulas podem ficar presas já que as forças se balanceiam e o $gBest$ não muda mais, como é possivel ver na \hyperref[fig:stuck-por-minimolocal]{Figura \ref{fig:stuck-por-minimolocal}}.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a uma imagem de um stuck por minimo local aqui}
                \caption{Representação de \textit{stuck} por minimo local}
                \label{fig:stuck-por-minimolocal}
            \end{figure}
            
            
            Já a convergencia prematura acontece quando a um minimo local e por coincidencia a posição inical da maioria das particulas da população tende a ser atraido para o minimo local, logo a maioria da população para nesse ponto e o algoritmo termina em um estado como é mostrado na 
            \hyperref[fig:convergencia-prematura]{Figura \ref{fig:convergencia-prematura}} 
            ou seja, termina antes de encontrar uma solução tão boa quando seria possivel.\newline

            \begin{figure}[h]
                \centering
                \small{Incluir a convergencia prematura aqui aqui}
                \caption{Demonstração de convergencia prematura de uma população de particulas}
                \label{fig:convergencia-prematura}
            \end{figure}
            
         %
        %% Fim do [Influencia na Solução] %%
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.x
        \subsubsection{Implementação}
            Durante a implementação de um algoritmo para geração do espaço de soluções, foram percebidos diversos detalhes que influenciam fortemente na qualidade final do algoritmo. Nessa seção será analisado alguns desses pontos.

            \subsubsubsection{Inicialização}
                Um ponto importante que foi percebido e a forma como se ira inicializar o array no qual será armazenado o espaço de soluções.\newline

                O NumPy disponibiliza trés metodos de inicialização para um novo array sem um valor de preenchimento, dos quais cada um demonstrou um problema diferente para a implementação. Dentre eles: 
                \begin{itemize}
                    \item \textit{numpy.zeros}: Ao inicializar o array com todos os valor preenchidos com o valor "$0$", por causa do processo de embaralhamento das operações, o algoritmo pode acabar gerando resultados erroneos, nos quais por não existir uma maquina $M_0$ algumas operações não eram consideradas no resultado final, e por causa da falta de algumas operações a solução em questão tinha um valor de \textit{fitness} menor, o que tendia a fazer essa solução erronea a melhor.

                    \item \textit{numpy.ones}: Ao inicializar o array com todos os valor preenchidos com o valor "$1$", o algoritmos gerava soluções que tendiam a sobre carregar a maquina $M_1$ e assim os resultados finais tendiam a ter um valor de \textit{fitness} mais alto.

                    \item \textit{numpy.empty}: Esse metodo de inicialização diferentemente dos outros, não defini nenhum valor para os registros da matriz, somente aloca um bloco de memoria (semelhante ao \code{malloc} da linguagem C), o que o torna mais rapido, porém ele trás o revés de possivelmente ter valor errados, pois por simplesmente alocar um bloco de memoria, o array pode ser inicializado com valores estranhos devido a lixo de memoria.
                \end{itemize}

                \noindent Devido aos problemas citados acima, acaba sendo necessário de qualquer maneira percorer todo o array para setar valores. \newline 
                Então foi optado por utilizar um metodo de preenchimento de valores aleatorio, 
                gerados pela função \code{numpy.random.choice} que gera um array de valores aleatórios seguindo uma distribuição uniforme, 
                conforme demonstrado no Grafico da \hyperref[fig:distrib-uniforme]{Figura \ref{fig:distrib-uniforme}}.

                \begin{figure}[h]
                    \centering
                    \small{Incluir o grafico de distribuição aqui}
                    \caption{Grafico de distribuição de valores gerados pela função aleatoria}
                    \label{fig:distrib-uniforme}
                \end{figure}
                
             %
            %% Inicialização do Array

            Após as análises citadas acima foi feito uma modelagem e desenvolvido para esse trabalho o algoritmo de inicialização do espaço de soluções representado pelo 
            \hyperref[fig:pseudocodigo-solutionspace]{Pseudo codigo \ref{fig:pseudocodigo-solutionspace}}. 
            Além disso a implementação real em Python está no apêndice x desse trabalho.\hfill

            %% Todo - Apendice
            %% Todo - pseudo codigo
            \begin{figure}[h]
                \centering
                \small{Incluir o pseudo codigo de geração do espaço de soluções aqui}
                \caption{Pseudo código da geração do espaço de soluções}
                \label{fig:pseudocodigo-solutionspace}
            \end{figure}
         %
        %% Fim do [Implementação] %%
        
     %
    %% Fim do [Espaço de Soluções] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.3
    \subsection{Partícula}
        ....

        %% Movimentação vetorial
     %
    %% Fim do [Particula] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.4
    \subsection{População}
        O algoritmo PSO por ser um algoritmo baseado em inteligência populacional, é muito influenciado pela geração de população inicial, mesmo nos algoritmos com variações aonde a mutação e consequentemente evolução dos indivíduos da população, as características como inercia, velocidade, direção e posição desses indivíduos da população inicial são de grande importância.\newline


        

        ...
        Assim, as variações do algoritmo PSO implementadas nesse trabalho utilizam a mesma função geradora de população inicial, representada pelo pseudo-código   (Adicionar aqui).
     %
    %% Fim do [População] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.5
    \subsection{Algoritmos}
        %%
            ...
        %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Algoritmos
        %% 2.2.2.1
        \subsubsection{PSO — Básico}
        %% Fim do [PSO - Basico] %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Algoritmos
        %% 2.2.2.2
        \subsubsection{PSO — Dinâmico}
        %% Fim do [PSO - Dinamico] %%

     %
    %% Fim do [Algoritmos] %%
    
 %
%% Fim do [Arquitetura] %%



%% 2 ::: Desenvolvimento
%% 2.3
\section{Execuções}
    Pela natureza variável do ambiente em nuvem cada teste de algoritmo foi executado 30 vezes para obter uma média dos tempos de execução. O teste de performance consiste em executar o algoritmo uma vez com cada problema de teste e salvar os dados de \textit{makespan}, tempo de execução e \textit{fitness}.

    O teste de diversidade é feito apenas entre as variações de PSO Dinâmico, para saber a taxa de mutação da população e como isso influenciou no \textit{makespan} e no \textit{fitness} da solução.
%% Fim do [Execuções] %%



%% 2 ::: Desenvolvimento
%% 2.4
\section{Critérios de Avaliação}
    A partir das médias estatísticas das execuções, são utilizados como critérios de avaliação do algoritmo o tempo de \textit{makespan}, o \textit{fitness} representado pelo diagrama de Gantt como pode ser visto no exemplo da 
    \hyperref[fig:exemplo-gantt]{Figura \ref{fig:exemplo-gantt}}
    . No caso das variações dinâmicas do PSO a taxa de mutação da população.

    % Todo - Inserir diagrama de Gantt Aqui %
    \begin{figure}[h]
        \centering
        \small{Incluir a plotagem de gantt aqui}
        \caption{Exemplo de diagrama de Gantt para representação da solução}
        \label{fig:exemplo-gantt}
    \end{figure}
    

%% Fim do [Critérios de Avaliação] %%



%% 2 ::: Desenvolvimento
%% 2.5
\section{Resultados}
    (Ainda em desenvolvimento...)
    %\lipsum[1]
%% Fim do [Resultados] %%



%%%%%%%%%% Ir agr até a pagina 31 %%%%%%%%%%


% Esse captulo deve ir no minimo até a pagina 36