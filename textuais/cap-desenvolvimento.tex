%% 2 ::: Desenvolvimento
\chapter{Desenvolvimento}
%% Interlúdio do [Desenvolvimento] %%
    ...
%% Fim do Interlúdio do [Desenvolvimento] %%


%% 2 ::: Desenvolvimento
%% 2.1
\section{Metodologia de Pesquisa}
    %% Interlúdio do [Metodologia de Pesquisa] %%
        Para os testes deste trabalho estão sendo usados os mesmo problemas utilizados por \cite{Kacem2002}, e já são largamente usados na literatura. Sendo representados por $[j, o, m]$ em que $j$ é a quantidade de \textit{jobs}, $o$ é a quantidade de operações e $m$ a quantidade de máquinas. Para observar o comportamento do algoritmo em diversos cenários foram escolhidos problemas de tamanhos variados, sendo eles $[4, 12, 5]$, $[10, 29, 7]$, $[10, 30, 10]$ e $[15, 56, 10]$. Os problemas de teste podem ser encontrados nos apêndices do trabalho.\newline

        Os algoritmos foram executados no ambiente de nuvem Google Colab Code sendo executado no motor \textit{Python 3 Google Compute Engine Backend}. Para a execução foram utilizados somente processadores comuns (CPU) e 12 Gb de memória RAM.
    %% Fim do Interlúdio do [Metodologia de Pesquisa] %%

    %% 2 ::: Desenvolvimento
    %% 2.1 ::: Metodologia de Pesquisa
    %% 2.1.1
    \subsection{Objetivos}
        Atualmente existem poucos estudos sobre o comportamento do PSO com componentes dinamicos em cenarios mono objetivos, principalmente em problemas com o FJSP. \newline

        Com as implementações feitas nesse trabalho se espera não uma analise crua de numeros e metricas de desempenho, mas sim ideias de como certas alterações afetam o desempenho do algoritmo, e quais são as tendencias de mudanças. \newline
        
        Para assim poder propor novas abordagens que tenham maior chance de serem proitosas em diversos cenarios e aplicações no mundo real.
     %
    %% Fim do [Objetivos] %%
 %
%% Fim do [Metodologia de Pesquisa] %%


%% 2 ::: Desenvolvimento
%% 2.2
\section{Arquitetura}
    %% Interlúdio do [Arquitetura] %%
        A arquitetura de um projeto de é um fator que impacta diretamente no seu desempenho, porém como o objetivo desse trabalho é entender como o algoritmo PSO se comporta diante das alterações propostas, foi necessário o desenvolvimento de uma arquitetura que represente o problema de maneira mais abstrata.
    %% Fim do Interlúdio do [Arquitetura] %%

    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.1
    \subsection{Design do Projeto}
        Por esse trabalho ser desenvolvimento dentro de um grupo de estudos, foi optado por usar uma estrutura de projeto mais didática e de fácil entendimento, de maneira que possa ser facilmente reutilizada por futuros estudantes. Porém, essa escolha acarreta uma certa perda de desempenho, porém, como se trata de um trabalho que visa explorar como cada tipo de alteração impacta o algoritmo, essa perca de desempenho não se torna um defeito.\newline
        
        O projeto foi desenvolvido na linguagem de programação Python versão 3.9.7 e utiliza além das bibliotecas básicas da linguagem, as bibliotecas:
        \begin{itemize}
            \item NumPy (versão 1.21.3)
            \item MatPlotlib (versão 3.4.3)
        \end{itemize}

        \hfill\newline
        \noindent O MatPlotlib foi utilizado para a geração de: 
        \begin{itemize}
            \item Gráficos de Dispersão (\textit{Scatter Plot}) para representar a posição das partículas da população.
            \item Gráficos de Superfície (\textit{Surface Plot}) para representar o espaço de soluções.
            \item Gráficos de Barra Horizontal (\textit{Horizontal Bar Plot}) para representar um diagrama de Gantt com a solução do agendamento.
        \end{itemize}
        
        \hfill\newline
        \noindent O NumPy foi utilizado para: 
        \begin{itemize}
            \item Grandes arranjos multi dimensionais de dados. 
            \item Funções randômicas de escolha.
            \item Ordenação de dados.
            \item Operações de cálculo como raiz quadrada e potenciação.
            \item Funções de escolha de valores máximos e mínimos.
            \item Modelagem, união e remodelagem de matrizes.
            \item Representações e calculo de vetores de movimentação.
        \end{itemize}
        
        \hfill\newline
        Para trazer mais clareza ao código foi optado por criar algumas classes para a representação de entidades e abstração de lógicas. Dentre elas estão:\newline
        
        Classe de Partícula, que faz a representação de uma entidade de partícula e armazena sua posição, velocidade e direção. Faz a inicialização da partícula com valores aleatórios de posição, velocidade e direção. E estabelece métodos para calcular o movimento da partícula e o valor da qualidade de sua nova posição.\newline
        
        Classe de \textit{encoding}, responsável por ler e interpretar os arquivos de instância de um problema, criar uma representação para de solução, e então gerar o espaço de soluções com soluções geradas aleatoriamente.\newline
         
        Classe de \textit{decoding}, responsável por decodificar uma solução no padrão de representação estabelecido pela classe de \textit{encoding} e calcular o \textit{fitness} dessa solução. Essa classe também estabelece o método que gera o gráfico de Gantt para representar visualmente a solução.\newline
        

        Como o PSO é um algoritmo estocástico, ou seja, seu resultado é fruto de eventos não previsíveis, como a geração aleatória de soluções, foi decidido que para obter uma média real dos desempenhos de cada algoritmo, em cada uma das 30 execuções será gerado um novo espaço de soluções e uma população inicial diferente.\newline
        E em cada uma dessas execuções será passado para cada um dos algoritmos uma \textit{Deepcopy} do espaço de soluções e da população inicial, para que os diferentes algoritmos trabalhem com base nos mesmos dados iniciais, para assim tem uma análise mais justa.\newline

        Para que a análise dos dados possa ser feita mais detalhadamente, foram implementados alguns pontos de salvamento de dados, para salvar em arquivo texto as representações da população e do espaço de soluções gerados aleatoriamente, assim como a quantidade de rodadas feitas, o histórico da variavel $gBest$, o número de mudanças de $pBest$, o histórico de posição das partículas e as soluções finais encontradas.
     %
    %% Fim do [Design do Projeto] %%
    

    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.2
    \subsection{Espaço de Soluções}
        %% Interludio %%
            O espaço de soluções (também chamado espaço de busca) é um conceito que define um espaço imaginário aonde cada ponto desse espaço é uma possível solução para o problema em questão. 
            Um espaço de soluções pode ser representado de diversas maneiras, como listas e grafos, mas em problemas de optimização normalmente se usa uma representação na forma de uma matriz.\newline
        %% Fim do [Interludio] %%
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.1
        \subsubsection{Representações}
            Nessa representação em forma de matriz cada localização $[i, j]$ tem uma solução valida para o problema, e o algoritmo em questão tem a tarefa de encontrar qual dessas posições tem a melhor solução, ou uma solução boa o suficiente. Na 
            \hyperref[fig:solution-space]{Figura \ref{fig:solution-space}} 
            é mostrado uma representação conceitual de um espaço de soluções em forma de matriz.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a imagem do exemplo de espaço de solução aqui}
                \caption{Figura X}
                \label{fig:solution-space}
            \end{figure}

            Algumas das implementações encontradas em bibliotecas de algoritmos populacionais de código aberto como \textit{PySwarms} utilizam internamente um sistema de representação de espaço de soluções de uma única dimensão, ou seja, uma lista simples, e utiliza uma função para transformar uma posição $[x,y]$ em um índice da lista. Essa implementação provavelmente foi escolhida por ser na maioria dos casos, mais rápida em comparação a uma abordagem de duas dimensões. \newline
        %% Fim do [Representações] %%


        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.2
        \subsubsection{Gráficos de análise}
            Como esse trabalho tem como foco uma exploração e implementação mais didática foi optado a utilização de uma representação em forma de uma matriz com duas dimensões, utilizando a biblioteca \textit{NumPy}. Essa abordagem em matriz de duas dimensões também facilita a geração de gráficos para representação visual, como, por exemplo, passar a matriz de soluções pela função de avaliação e assim obter um valor de \textit{fitness} para cada ponto do espaço de soluções, como é possível ver na 
            \hyperref[fig:surfaceplot]{Figura \ref{fig:surfaceplot}} 
            na qual os valores mais acima e mais escuros tem um valor de \textit{fitness} mais alto (ou seja, pior), e os valores mais abaixo e mais claros tem um \textit{fitness} mais baixo (ou seja, melhor).\newline

            \begin{figure}[h]
                \centering
                \small{Incluir a grafico surface aqui}
                \caption{Gráfico surface simples}
                \label{fig:surfaceplot}
            \end{figure}

            Esses gráficos se mostraram extremamente uteis ao decorrer do desenvolvimento deste trabalho, servindo para validar detectar erros na função de inicialização do espaço de soluções.\newline
        %% Fim do [Graficos de Analise] %%


        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.3
        \subsubsection{Influencia na Solução}
            A geração do espaço de soluções é muito importante no caso de um algoritmo como o PSO 
            que funciona com base na movimentação de acordo com as médias de melhores posições, 
            devido a isso, o PSO tente a ter problemas com convergencia prematura em minimos locais.\newline
            
            Os minimos locais são fenomenos aonde dentro de uma parte do espaço de soluções existe um ponto que é melhor do que a media dos pontos a sua volta, porém não é o melhor entre o todo o espaço de soluções, como é possivel ver na \hyperref[fig:ex-minimolocal]{Figura \ref{fig:ex-minimolocal}}.\newline
            \begin{figure}[h]
                \centering
                \small{Incluir um grafico de minimo local aqui}
                \caption{Exemplo de um minimo local}
                \label{fig:ex-minimolocal}
            \end{figure}
            

            Já que esse ponto se destaca muito entre seus vizinhos o algoritmo pode ficar preso nesta região, pois a media local sempre tende para o ponto no qual está o minimo local.\newline

            Como o PSO se baseia na media local e global, se houver mais de um minimo local e quantidades equivalentes de particulas da população forem distribuidas para esses pontos, as particulas podem ficar presas já que as forças se balanceiam e o $gBest$ não muda mais, como é possivel ver na \hyperref[fig:stuck-por-minimolocal]{Figura \ref{fig:stuck-por-minimolocal}}.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a uma imagem de um stuck por minimo local aqui}
                \caption{Representação de \textit{stuck} por minimo local}
                \label{fig:stuck-por-minimolocal}
            \end{figure}
            
            
            Já a convergencia prematura acontece quando a um minimo local e por coincidencia a posição inical da maioria das particulas da população tende a ser atraido para o minimo local, logo a maioria da população para nesse ponto e o algoritmo termina em um estado como é mostrado na 
            \hyperref[fig:convergencia-prematura]{Figura \ref{fig:convergencia-prematura}} 
            ou seja, termina antes de encontrar uma solução tão boa quando seria possivel.\newline

            \begin{figure}[h]
                \centering
                \small{Incluir a convergencia prematura aqui aqui}
                \caption{Demonstração de convergencia prematura de uma população de particulas}
                \label{fig:convergencia-prematura}
            \end{figure}
            
         %
        %% Fim do [Influencia na Solução] %%
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.4
        \subsubsection{Implementação}
            Durante a implementação de um algoritmo para geração do espaço de soluções, foram percebidos diversos detalhes que influenciam fortemente na qualidade final do algoritmo. Nessa seção será analisado alguns desses pontos.

            \subsubsubsection{Inicialização}
                Um ponto importante que foi percebido e a forma como se ira inicializar o array no qual será armazenado o espaço de soluções.\newline

                O NumPy disponibiliza trés metodos de inicialização para um novo array sem um valor de preenchimento, dos quais cada um demonstrou um problema diferente para a implementação. Dentre eles: 
                \begin{itemize}
                    \item \textit{numpy.zeros}: Ao inicializar o array com todos os valor preenchidos com o valor "$0$", por causa do processo de embaralhamento das operações, o algoritmo pode acabar gerando resultados erroneos, nos quais por não existir uma maquina $M_0$ algumas operações não eram consideradas no resultado final, e por causa da falta de algumas operações a solução em questão tinha um valor de \textit{fitness} menor, o que tendia a fazer essa solução erronea a melhor.

                    \item \textit{numpy.ones}: Ao inicializar o array com todos os valor preenchidos com o valor "$1$", o algoritmos gerava soluções que tendiam a sobre carregar a maquina $M_1$ e assim os resultados finais tendiam a ter um valor de \textit{fitness} mais alto.

                    \item \textit{numpy.empty}: Esse metodo de inicialização diferentemente dos outros, não defini nenhum valor para os registros da matriz, somente aloca um bloco de memoria (semelhante ao \code{malloc} da linguagem C), o que o torna mais rapido, porém ele trás o revés de possivelmente ter valor errados, pois por simplesmente alocar um bloco de memoria, o array pode ser inicializado com valores estranhos devido a lixo de memoria.
                \end{itemize}

                \noindent Devido aos problemas citados acima, acaba sendo necessário de qualquer maneira percorer todo o array para setar valores. \newline 
                Então foi optado por utilizar um metodo de preenchimento de valores aleatorio, 
                gerados pela função \code{numpy.random.choice} que gera um array de valores aleatórios seguindo uma distribuição uniforme, 
                conforme demonstrado no Grafico da \hyperref[fig:distrib-uniforme]{Figura \ref{fig:distrib-uniforme}}.

                \begin{figure}[h]
                    \centering
                    \small{Incluir o grafico de distribuição aqui}
                    \caption{Grafico de distribuição de valores gerados pela função aleatoria}
                    \label{fig:distrib-uniforme}
                \end{figure}
                
             %
            %% Inicialização do Array

            Após as análises citadas acima foi feito uma modelagem e desenvolvido para esse trabalho o algoritmo de inicialização do espaço de soluções representado pelo 
            \hyperref[fig:pseudocodigo-solutionspace]{Pseudo codigo \ref{fig:pseudocodigo-solutionspace}}. 
            Além disso a implementação real em Python está no apêndice x desse trabalho.\hfill

            %% Todo - Apendice
            %% Todo - pseudo codigo
            \begin{figure}[h]
                \centering
                \small{Incluir o pseudo codigo de geração do espaço de soluções aqui}
                \caption{Pseudo código da geração do espaço de soluções}
                \label{fig:pseudocodigo-solutionspace}
            \end{figure}
         %
        %% Fim do [Implementação] %%
        
     %
    %% Fim do [Espaço de Soluções] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.3
    \subsection{Partícula}
        %% Interludio %%
            Por se tratar de um algoritmo populacional focado em particulas, por isso o nome \textit{Particle Swarm Optimization} que significa Otimização por Enxame de Particulas, a representação dessa entidade, assim como sua geração, controle e movimentação, se mostra um dos principais pilares do algoritmo. Devido a criterios de legibilidade e facilitação de futuros estudos nesse trabalho foi optado por criar uma estrutura de classe bem definida para essa representação e controle.
        %% Fim do [Interludio] %%
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.3 ::: Partícula
        %% 2.2.3.1
        \subsubsection{Implementação}
            Nessa classe são guardados os valores de: posição, velocidade e $pBest$, além de outros dados que são utilizados para facilitar o gerenciamento como: valor da solução da sua atual posição, assim como seu valor de \textit{fitness} e o tamanho do espaço de soluções. \newline

            Para fazer uma melhor movimentação foi optado por nao usar uma variavel de direção, mas sim uma variavel que guarda a ultima posição na qual a particula esteve.\newline
            Além da armazenagem dos valores da particula, a classe da Particula também implementa algumas funções como:\newline
            
            Função \textbf{\code{fill\_with\_random\_values}} que gera uma posição inicial e uma velocidade aleatoria para a particula.\newline
            
            Função \textbf{\code{evaluate\_value}} que faz o calculo do valor de \textit{fitness} da atual posição e a comparação do valor com o atual valor de $pBest$ e atualiza o $pBest$ caso o novo valor seja melhor.\newline

            Função \textbf{\code{update\_position}} que faz a movimentação da particula.\newline
            

            \noindent A implementação de toda a classe de particula está disponivel no apendice x desse trabalho.\newline

            %% TODO - Apendice
            
            
            Em implementações de codigo aberto como a já citada \textit{PySwarms}, também se utiliza uma representação de classe, porém sem nenhuma responsabilidade de calculo de \textit{fitness}, atualização de posição ou de preenchimento de valores aleatorios na particula.\newline

         %
        %% Fim do [Representações] %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.3 ::: Partícula
        %% 2.2.3.3
        \subsubsection{Movimentação}
            A movimentação da particula no espaço de soluções é o ponto mais importante dessa entidade. Pois se não for feita da maneira certa pode fazer o algoritmo não desempenhar tão quanto o possivel.\newline
            
            Como a implementação do espaço de soluções foi feita utilizando uma representação matricial, o mecanismo de movimentação mais intuitivo seria uma movimentação por soma de inteiros.\newline
            Aonde se tem uma direção e com base nessa direção se soma ou substrai o valor de velocidade do eixo de movimento e assim se obtem uma nova posição, como mostrado no 
            \hyperref[alg:mov-int-sum]{Pseudocodido \ref{alg:mov-int-sum}}.\newline

            \begin{figure}[h]
                \centering
                \small{Incluir o pseudo codigo de uma movimentação por soma de inteiros aqui}
                \caption{Pseudocodido de uma movimentação por soma de inteiros}
                \label{alg:mov-int-sum}
            \end{figure}
            
            Ou seja, tendo uma posição $[15, 7]$ sendo $15$ o valor de $x$ e $7$ o valor de $y$,
            uma velocidade $2$ e a direção do movimento ser \code{CIMA}, a nova posição é obtida incrementado a velocidade ao valor de $y$ da posição, ou seja $[15, 7+2]$, então a nova posição seria $[15, 9]$, como pode ser visto na 
            \hyperref[fig:movimentacao-int-sum]{Figura \ref{fig:movimentacao-int-sum}}.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a demonstração de movimentação por soma de inteiros aqui}
                \caption{Demonstração de movimentação por soma de inteiro}
                \label{fig:movimentacao-int-sum}
            \end{figure}
            
            Essa abordagem funciona bem para uma movimentação simples em espaços 2D. Sendo inclusive muito utilizada no desenvolvimento de jogos com mapas baseados em ladrilhos (\textit{Tile-based} / \textit{Grid-based}).\newline
            
            Porém no caso do algoritmo PSO é necessario que ao calcular a nova posição, se leve em conta a inercia e uma media entre o $pBest$ e o $gBest$, o que muitas vezes gera uma movimentação em angulos mais especificos como representado na 
            \hyperref[fig:angular-moviment-grid-based]{Figura \ref{fig:angular-moviment-grid-based}}
            o que torna essa abordagem de soma de inteiros muito complexa e limitada para esse cenario.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a imagem demonstrativa de movimentação com angulos estranhos aqui}
                \caption{Exemplo de movimentação com angulos complexos}
                \label{fig:angular-moviment-grid-based}
            \end{figure}
            
            %%%%
            
            Então nesse trabalho foi desenvolvido um metodo de movimentação baseado em calculos vetoriais que elimina esses problemas movimentação além de facilitar a implementação de novos pontos de comparação (além do $pBest$ e $gBest$) para o calculo da nova posição.\newline
            
            \subsubsubsection{Movimentação Vetorial}
                Essa abordagem de movimentação é baseado no conceito de \textit{Produto Escalar} definido pela Algebra Linear, e representa o produto interno padrão do espaço euclidiano e é representado por uma operação binaria entre dois vetores.\newline
                
                \noindent Em um cenario aonde a posição da particula é $position=[12,8]$ e $pBest=[10, 15]$, $gBest=[16,20]$ e $velocidade=[2,4]$.

                \noindent Para encontrar a nova posição de uma uma particula são utilizados:
                \begin{itemize}
                    \item $\vec p$ Que representa o vetor entre a particula e o $pBest$ 
                        (\hyperref[fig:vetor-p]{Figura \ref{fig:vetor-p}}).
                    \item $\vec g$ Que representa o vetor entre a particula e o $gBest$ 
                        (\hyperref[fig:vetor-g]{Figura \ref{fig:vetor-g}}).
                    \item $\vec w$ Que representa o vetor de inercia da particula, que é o vetor resultante da soma da posição atual com o valor da velocidade 
                        (\hyperref[fig:vetor-w]{Figura \ref{fig:vetor-w}}).
                \end{itemize}

                \begin{figure}[!htb]
                    \begin{minipage}{\textwidth}

                        % 1º linha
                        \begin{minipage}{0.5\textwidth}
                            \centering
                            %\includegraphics[width=.8\linewidth]{example-image-a}
                            \small{Incluir vetor v aqui}
                            \caption{xxxx}
                            \label{fig:vetor-v}
                        \end{minipage}
                        \begin{minipage}{0.5\textwidth}
                            \centering
                            %\includegraphics[width=.8\linewidth]{example-image-b}
                            \small{Incluir vetor p aqui}
                            \caption{xxxx}
                            \label{fig:vetor-p}
                        \end{minipage}

                        % 2º linha
                        \begin{minipage}{0.5\textwidth}
                            \centering
                            %\includegraphics[width=.8\linewidth]{example-image-a}
                            \small{Incluir vetor g aqui}
                            \caption{xxxx}
                            \label{fig:vetor-g}
                        \end{minipage}
                        \begin{minipage}{0.5\textwidth}
                            \centering
                            %\includegraphics[width=.8\linewidth]{example-image-b}
                            \small{Incluir vetor w aqui}
                            \caption{xxxx}
                            \label{fig:vetor-w}
                        \end{minipage}

                    \end{minipage}
                \end{figure}

                \noindent A nova posição da particula é dada pela 
                \hyperref[fig:formula-nova-posicao]{Formula \ref{fig:formula-nova-posicao}}.
                
                \begin{figure}[h]
                    \centering
                    \small{Incluir a Formula de posição particula aqui}
                    \caption{Formula que define a nova posição da particula}
                    \label{fig:formula-nova-posicao}
                \end{figure}

                \noindent Então temos o vetor $\vec r$ resultante, então a nova posição da particula é $[12,10]$.
                
                No codigo Python essa implementação é feita de maneira levemente diferente por características da linguagem. Para realizar os calculos vetoriais foi utilizado a biblioteca \textit{Numpy}. \newline
                
                Para isso primeiro é calculo um vetor medio entre $pBest$ e $gBest$, e o vetor $\vec w$ representando a inercia. \newline
                Então a posição atual da particula é deduzido do valor medio entre medio entre $pBest$ e $gBest$, isso é feito para que calcular o vetor como se a posição atual da particula fosse o ponto $[0,0]$ do mapa.\newline
                Então somado com o vetor de inercia divido por um valor de significancia para a inercia (Definido pelos parametros de configuração do algoritmo).\newline

                No \hyperref[cod:new-posicao]{Pseudocodido \ref{cod:new-posicao}} é possivel ver a representação dessa função de calculo, e a implementação desse metodoestá disponivel no apendice x.
                
                %% TODO - apendice
                \begin{figure}[h]
                    \centering
                    \small{Incluir o psudocodigo de movimentação aqui}
                    \caption{Pseudocodigo da função de calculo de movimentação de particula}
                    \label{cod:new-posicao}
                \end{figure}

             %
            %% Fim do [Movimentação Vetorial] %%


         %
        %% Fim do [Movimentação] %%

     %
    %% Fim do [Particula] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.4
    \subsection{População}
        Pelo algoritmo PSO ser um algoritmo baseado em inteligência populacional, ele é muito influenciado pela geração da população inicial, mesmo nos algoritmos com variações aonde existem mutação e consequentemente evolução dos indivíduos da população, as características como inercia, velocidade, direção e posição desses indivíduos da população inicial são de grande importância.\newline

        Os parametros como o tamanho da população são definido nas configuração do algoritmo. Todas as funções utilizadas na geração dos individuos seguem o padrão de distribuição uniforme.\newline
        
        A possição inicial da particula é dada por dois numeros aleatorios entre $1$ e o limite do espaço de soluções - $1$.\newline
        
        A ultima posição da particula é obtida atravez de um sorteio de chances iguais que pode ou subtraindo ou adicionar $1$ na posição inicial gerada anteriormente. Caso seja subtraido $1$ a direção de movimentação é para frente, caso seja subtraido $1$ a direção do movimento é para trás.\newline

        A velocidade é dada por um valor aleatorio entre $0.1$ e $0.2$.\newline

        Assim, como valores iniciais seguindo uma distribuição uniforme é observado uma geração de população inicial bem distribuida, dificultando o acontecimento de convergencia prematura.
        
        Sendo assim, todas as variações do algoritmo PSO implementadas nesse trabalho utilizam a mesma função geradora de população inicial, representada pelo pseudo-código \hyperref[cod:geracao-pop]{Pseudocodido \ref{cod:geracao-pop}}.
        
        \begin{figure}[h]
            \centering
            \small{Incluir a pseudo codigo da geração populacional aqui}
            \caption{Pseudocodigo de geração populacional}
            \label{cod:geracao-pop}
        \end{figure}
        
        \noindent Garantindo assim um ponto de comparação mais justo entre os algoritmos.

     %
    %% Fim do [População] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.5
    \subsection{Algoritmos}
        %%
            ...
        %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Algoritmos
        %% 2.2.2.1
        \subsubsection{PSO — Básico}
        %% Fim do [PSO - Basico] %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Algoritmos
        %% 2.2.2.2
        \subsubsection{PSO — Dinâmico}
        %% Fim do [PSO - Dinamico] %%

     %
    %% Fim do [Algoritmos] %%
    
 %
%% Fim do [Arquitetura] %%



%% 2 ::: Desenvolvimento
%% 2.3
\section{Execuções}
    Pela natureza variável do ambiente em nuvem cada teste de algoritmo foi executado 30 vezes para obter uma média dos tempos de execução.\newline
    
    Como foi descrito anteriormentem, afim de asegurar uma analise mais detalhada, os dados gerados pelos algoritmos foram salvos em aquivo texto para analise detalhada.\newline
    
    Os dados salvos são:
    \begin{itemize}
        \item População inicial.
        \item Espaço de soluções.
        \item Numeros de rodadas do algoritmo.
        \item Historico da variavel $gBest$.
        \item Historico da variavel $pBest$.
        \item Historico da posição das particulas.
        \item Soluções encontradas.
    \end{itemize}
    
    (Dados a completar...)
 % 
%% Fim do [Execuções] %%


%% 2 ::: Desenvolvimento
%% 2.4
\section{Critérios de Avaliação}
    A partir das médias estatísticas das execuções, são utilizados como critérios de avaliação do algoritmo: \newline
    
    \begin{itemize}
        \item Tempo total de execução do algoritmo.
        \item Fitness final.
    \end{itemize}
    


    E são parametros de analise:\newline
    
    \begin{itemize}
        \item Taxa de mudança da variavel $gBest$ ao longo da execução.
        \item Quantidade de rodadas necessarias para atingir o criterio de parada.
        \item Taxa de mudanças de $pBest$ por rodada.
        \item Historico de movimentação das particulas.
    \end{itemize}

    Além desses criterios também é possivel observar os dados e tirar outras concluções sobre o comportamento do algoritmo.\newline
    
 %
%% Fim do [Critérios de Avaliação] %%


%% 2 ::: Desenvolvimento
%% 2.5
\section{Resultados}
    (Dados a completar...)
 %
%% Fim do [Resultados] %%
