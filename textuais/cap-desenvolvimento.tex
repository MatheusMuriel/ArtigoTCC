%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 2 ::: Desenvolvimento
\chapter{Desenvolvimento}
    %% Interlúdio do [Desenvolvimento] %%
        ...
    %% Fim do Interlúdio do [Desenvolvimento] %%


%% 2 ::: Desenvolvimento
%% 2.1
\section{Metodologia de Pesquisa}
    %% Interlúdio do [Metodologia de Pesquisa] %%
        Para os testes deste trabalho estão sendo usados os mesmo problemas utilizados por \cite{Kacem2002}, e já são largamente usados na literatura. Sendo representados por $[j, o, m]$ em que $j$ é a quantidade de \textit{jobs}, $o$ é a quantidade de operações e $m$ a quantidade de máquinas. Para observar o comportamento do algoritmo em diversos cenários foram escolhidos problemas de tamanhos variados, sendo eles $[4, 12, 5]$, $[10, 29, 7]$, $[10, 30, 10]$ e $[15, 56, 10]$. Os problemas de teste podem ser encontrados nos apêndices do trabalho.\newline

        Os algoritmos foram executados no ambiente de nuvem Google Colab Code sendo executado no motor \textit{Python 3 Google Compute Engine Backend}. Para a execução foram utilizados somente processadores comuns (CPU) e 12 Gb de memória RAM.
    %% Fim do Interlúdio do [Metodologia de Pesquisa] %%

    %% 2 ::: Desenvolvimento
    %% 2.1 ::: Metodologia de Pesquisa
    %% 2.1.1
    \subsection{Objetivos}
        ... Bla bla bla ...Analise visa descobrir e analisar como as alterações afetam a qualidade do algoritmo... Bla bla bla...
    %% Fim do [Objetivos] %%
 %
%% Fim do [Metodologia de Pesquisa] %%


%% 2 ::: Desenvolvimento
%% 2.2
\section{Arquitetura}
    %% Interlúdio do [Arquitetura] %%
        A arquitetura de um projeto de é um fator que impacta diretamente no seu desempenho, porém como o objetivo desse trabalho é entender como o algoritmo PSO se comporta diante das alterações propostas, foi necessário o desenvolvimento de uma arquitetura que represente o problema de maneira mais abstrata.
    %% Fim do Interlúdio do [Arquitetura] %%

    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.1
    \subsection{Design do Projeto}
        Por esse trabalho ser desenvolvimento dentro de um grupo de estudos, foi optado por usar uma estrutura de projeto mais didática e de fácil entendimento, de maneira que possa ser facilmente reutilizada por futuros estudantes. Porém, essa escolha acarreta uma certa perda de desempenho, porém, como se trata de um trabalho que visa explorar como cada tipo de alteração impacta o algoritmo, essa perca de desempenho não se torna um defeito.\newline
        
        O projeto foi desenvolvido na linguagem de programação Python versão 3.9.7 e utiliza além das bibliotecas básicas da linguagem, as bibliotecas:
        \begin{itemize}
            \item NumPy (versão 1.21.3)
            \item MatPlotlib (versão 3.4.3)
        \end{itemize}

        \noindent O MatPlotlib foi utilizado para a geração de: 
        \begin{itemize}
            \item Gráficos de Dispersão (\textit{Scatter Plot}) para representar a posição das partículas da população.
            \item Gráficos de Superfície (\textit{Surface Plot}) para representar o espaço de soluções.
            \item Gráficos de Barra Horizontal (\textit{Horizontal Bar Plot}) para representar um diagrama de Gantt com a solução do agendamento.
        \end{itemize}

        \noindent O NumPy foi utilizado para: 
        \begin{itemize}
            \item Grandes arranjos multi dimensionais de dados. 
            \item Funções randômicas de escolha.
            \item Ordenação de dados.
            \item Operações de cálculo como raiz quadrada e potenciação.
            \item Funções de escolha de valores máximos e mínimos.
            \item Modelagem, união e remodelagem de matrizes.
            \item Representações e calculo de vetores de movimentação.
        \end{itemize}
        
        Para trazer mais clareza ao código foi optado por criar algumas classes para a representação de entidades e abstração de lógicas. Dentre elas estão:\newline
        
        Classe de Partícula, que faz a representação de uma entidade de partícula e armazena sua posição, velocidade e direção. Faz a inicialização da partícula com valores aleatórios de posição, velocidade e direção. E estabelece métodos para calcular o movimento da partícula e o valor da qualidade de sua nova posição.\newline
        
        Classe de \textit{encoding}, responsável por ler e interpretar os arquivos de instância de um problema, criar uma representação para de solução, e então gerar o espaço de soluções com soluções geradas aleatoriamente.\newline
         
        Classe de \textit{decoding}, responsável por decodificar uma solução no padrão de representação estabelecido pela classe de \textit{encoding} e calcular o \textit{fitness} dessa solução. Essa classe também estabelece o método que gera o gráfico de Gantt para representar visualmente a solução.\newline
        

        Como o PSO é um algoritmo estocástico, ou seja, seu resultado é fruto de eventos não previsíveis, como a geração aleatória de soluções, foi decidido que para obter uma média real dos desempenhos de cada algoritmo, em cada uma das 30 execuções será gerado um novo espaço de soluções e uma população inicial diferente.\newline
        E em cada uma dessas execuções será passado para cada um dos algoritmos uma \textit{Deepcopy} do espaço de soluções e da população inicial, para que os diferentes algoritmos trabalhem com base nos mesmos dados iniciais, para assim tem uma análise mais justa.\newline

        Para que a análise dos dados possa ser feita mais detalhadamente, foram implementados alguns pontos de salvamento de dados, para salvar em arquivo texto as representações da população e do espaço de soluções gerados aleatoriamente, assim como a quantidade de rodadas feitas, o histórico da variavel $gBest$, o número de mudanças de $pBest$, o histórico de posição das partículas e as soluções finais encontradas.
     %
    %% Fim do [Design do Projeto] %%
    

    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.2
    \subsection{Espaço de Soluções}
        O espaço de soluções (também chamado espaço de busca) é um conceito que define um espaço imaginário aonde cada ponto desse espaço é uma possível solução para o problema em questão. Um espaço de soluções pode ser representado de diversas maneiras, como listas e grafos, mas em problemas de optimização normalmente se usa uma representação na forma de uma matriz.\newline
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.1
        \subsubsection{Representações}
            Nessa representação em forma de matriz cada localização $[i, j]$ tem uma solução valida para o problema, e o algoritmo em questão tem a tarefa de encontrar qual dessas posições tem a melhor solução, ou uma solução boa o suficiente. Na 
            \hyperref[fig:solution-space]{Figura \ref{fig:solution-space}} 
            é mostrado uma representação conceitual de um espaço de soluções em forma de matriz.\newline
            
            \begin{figure}[h]
                \centering
                \small{Incluir a imagem do exemplo de espaço de solução aqui}
                \caption{Figura X}
                \label{fig:solution-space}
            \end{figure}

            Algumas das implementações encontradas em bibliotecas de algoritmos populacionais de código aberto como \textit{PySwarms} utilizam internamente um sistema de representação de espaço de soluções de uma única dimensão, ou seja, uma lista simples, e utiliza uma função para transformar uma posição $[x,y]$ em um índice da lista. Essa implementação provavelmente foi escolhida por ser na maioria dos casos, mais rápida em comparação a uma abordagem de duas dimensões. \newline
        %% Fim do [Representações] %%

        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.2
        \subsubsection{Gráficos de análise}
            Como esse trabalho tem como foco uma exploração e implementação mais didática foi optado a utilização de uma representação em forma de uma matriz com duas dimensões, utilizando a biblioteca \textit{NumPy}. Essa abordagem em matriz de duas dimensões também facilita a geração de gráficos para representação visual, como, por exemplo, passar a matriz de soluções pela função de avaliação e assim obter um valor de \textit{fitness} para cada ponto do espaço de soluções, como é possível ver na 
            \hyperref[fig:surfaceplot]{Figura \ref{fig:surfaceplot}} 
            na qual os valores mais acima e mais escuros tem um valor de \textit{fitness} mais alto (ou seja, pior), e os valores mais abaixo e mais claros tem um \textit{fitness} mais baixo (ou seja, melhor).\newline

            \begin{figure}[h]
                \centering
                \small{Incluir a grafico surface aqui}
                \caption{Gráfico surface simples}
                \label{fig:surfaceplot}
            \end{figure}

            Esses gráficos se mostraram extremamente uteis ao decorrer do desenvolvimento deste trabalho, servindo para validar detectar erros na função de inicialização do espaço de soluções.\newline
        %% Fim do [Graficos de Analise] %%


        %% Influencia na solução

        %% Inicialização do Array

        %% Movimentação vetorial
        

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Espaço de Soluções
        %% 2.2.2.x
        \subsubsection{Implementação}
            E então depois de todas as análises acime e de modelagem foi desenvolvido para esse trabalho o algoritmo de inicialização populacional representado pelo 
            \hyperref[fig:pseudocodigo-solutionspace]{Pseudo codigo \ref{fig:pseudocodigo-solutionspace}} 
            mas que a implementação está no apêndice x desse trabalho.\hfill

            %% Todo - Apendice
            %% Todo - pseudo codigo
            \begin{figure}[h]
                \centering
                \small{Incluir o pseudo codigo de geração do espaço de soluções aqui}
                \caption{Pseudo código da geração do espaço de soluções}
                \label{fig:pseudocodigo-solutionspace}
            \end{figure}
        %% Fim do [Implementação] %%
        
     %
    %% Fim do [Espaço de Soluções] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.3
    \subsection{Partícula}
        ....
    %% Fim do [Particula] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.4
    \subsection{População}
        O algoritmo PSO por ser um algoritmo baseado em inteligência populacional, é muito influenciado pela geração de população inicial, mesmo nos algoritmos com variações aonde a mutação e consequentemente evolução dos indivíduos da população, as características como inercia, velocidade, direção e posição desses indivíduos da população inicial são de grande importância.\newline


        

        ...
        Assim, as variações do algoritmo PSO implementadas nesse trabalho utilizam a mesma função geradora de população inicial, representada pelo pseudo-código   (Adicionar aqui).
    %% Fim do [População] %%


    %% 2 ::: Desenvolvimento
    %% 2.2 ::: Arquitetura
    %% 2.2.5
    \subsection{Algoritmos}
        %%
            ...
        %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Algoritmos
        %% 2.2.2.1
        \subsubsection{PSO — Básico}
        %% Fim do [PSO - Basico] %%

        %% 2 ::: Desenvolvimento
        %% 2.2 ::: Arquitetura
        %% 2.2.2 ::: Algoritmos
        %% 2.2.2.2
        \subsubsection{PSO — Dinâmico}
        %% Fim do [PSO - Dinamico] %%

     %
    %% Fim do [Algoritmos] %%
    
 %
%% Fim do [Arquitetura] %%



%% 2 ::: Desenvolvimento
%% 2.3
\section{Execuções}
    Pela natureza variável do ambiente em nuvem cada teste de algoritmo foi executado 30 vezes para obter uma média dos tempos de execução. O teste de performance consiste em executar o algoritmo uma vez com cada problema de teste e salvar os dados de \textit{makespan}, tempo de execução e \textit{fitness}.

    O teste de diversidade é feito apenas entre as variações de PSO Dinâmico, para saber a taxa de mutação da população e como isso influenciou no \textit{makespan} e no \textit{fitness} da solução.
%% Fim do [Execuções] %%



%% 2 ::: Desenvolvimento
%% 2.4
\section{Critérios de Avaliação}
    A partir das médias estatísticas das execuções, são utilizados como critérios de avaliação do algoritmo o tempo de \textit{makespan}, o \textit{fitness} representado pelo diagrama de Gantt como pode ser visto no exemplo da 
    \hyperref[fig:exemplo-gantt]{Figura \ref{fig:exemplo-gantt}}
    . No caso das variações dinâmicas do PSO a taxa de mutação da população.

    % Todo - Inserir diagrama de Gantt Aqui %
    \begin{figure}[h]
        \centering
        \small{Incluir a plotagem de gantt aqui}
        \caption{Exemplo de diagrama de Gantt para representação da solução}
        \label{fig:exemplo-gantt}
    \end{figure}
    

%% Fim do [Critérios de Avaliação] %%



%% 2 ::: Desenvolvimento
%% 2.5
\section{Resultados}
    (Ainda em desenvolvimento...)
    %\lipsum[1]
%% Fim do [Resultados] %%



%%%%%%%%%% Ir agr até a pagina 31 %%%%%%%%%%


% Esse captulo deve ir no minimo até a pagina 36